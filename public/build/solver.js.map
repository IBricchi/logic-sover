{"version":3,"file":"solver.js","sources":["../../src/solver/src/.fable/fable-library.3.2.9/Util.js","../../src/solver/src/.fable/fable-library.3.2.9/Types.js","../../src/solver/src/.fable/fable-library.3.2.9/Int32.js","../../src/solver/src/.fable/fable-library.3.2.9/Numeric.js","../../src/solver/src/.fable/fable-library.3.2.9/lib/long.js","../../src/solver/src/.fable/fable-library.3.2.9/Date.js","../../src/solver/src/.fable/fable-library.3.2.9/String.js","../../src/solver/src/.fable/fable-library.3.2.9/List.js","../../src/solver/src/Lexer.fs.js","../../src/solver/src/.fable/fable-library.3.2.9/Seq.js","../../src/solver/src/Parser.fs.js","../../src/solver/src/Helper.fs.js","../../src/solver/src/Propositional.fs.js","../../src/solver/src/Solver.fs.js"],"sourcesContent":["// tslint:disable:ban-types\nexport function isIterable(x) {\n    return x != null && typeof x === \"object\" && Symbol.iterator in x;\n}\nexport function isArrayLike(x) {\n    return Array.isArray(x) || ArrayBuffer.isView(x);\n}\nfunction isComparer(x) {\n    return typeof x.Compare === \"function\";\n}\nfunction isComparable(x) {\n    return typeof x.CompareTo === \"function\";\n}\nfunction isEquatable(x) {\n    return typeof x.Equals === \"function\";\n}\nfunction isHashable(x) {\n    return typeof x.GetHashCode === \"function\";\n}\nexport function isDisposable(x) {\n    return x != null && typeof x.Dispose === \"function\";\n}\nexport function sameConstructor(x, y) {\n    return Object.getPrototypeOf(x).constructor === Object.getPrototypeOf(y).constructor;\n}\nexport class Enumerator {\n    constructor(iter) {\n        this.iter = iter;\n    }\n    [\"System.Collections.Generic.IEnumerator`1.get_Current\"]() {\n        return this.current;\n    }\n    [\"System.Collections.IEnumerator.get_Current\"]() {\n        return this.current;\n    }\n    [\"System.Collections.IEnumerator.MoveNext\"]() {\n        const cur = this.iter.next();\n        this.current = cur.value;\n        return !cur.done;\n    }\n    [\"System.Collections.IEnumerator.Reset\"]() {\n        throw new Error(\"JS iterators cannot be reset\");\n    }\n    Dispose() {\n        return;\n    }\n}\nexport function getEnumerator(o) {\n    return typeof o.GetEnumerator === \"function\"\n        ? o.GetEnumerator()\n        : new Enumerator(o[Symbol.iterator]());\n}\nexport function toIterator(en) {\n    return {\n        [Symbol.iterator]() { return this; },\n        next() {\n            const hasNext = en[\"System.Collections.IEnumerator.MoveNext\"]();\n            const current = hasNext ? en[\"System.Collections.IEnumerator.get_Current\"]() : undefined;\n            return { done: !hasNext, value: current };\n        },\n    };\n}\nexport class Comparer {\n    constructor(f) {\n        this.Compare = f || compare;\n    }\n}\nexport function comparerFromEqualityComparer(comparer) {\n    // Sometimes IEqualityComparer also implements IComparer\n    if (isComparer(comparer)) {\n        return new Comparer(comparer.Compare);\n    }\n    else {\n        return new Comparer((x, y) => {\n            const xhash = comparer.GetHashCode(x);\n            const yhash = comparer.GetHashCode(y);\n            if (xhash === yhash) {\n                return comparer.Equals(x, y) ? 0 : -1;\n            }\n            else {\n                return xhash < yhash ? -1 : 1;\n            }\n        });\n    }\n}\nexport function assertEqual(actual, expected, msg) {\n    if (!equals(actual, expected)) {\n        throw Object.assign(new Error(msg || `Expected: ${expected} - Actual: ${actual}`), {\n            actual,\n            expected,\n        });\n    }\n}\nexport function assertNotEqual(actual, expected, msg) {\n    if (equals(actual, expected)) {\n        throw Object.assign(new Error(msg || `Expected: ${expected} - Actual: ${actual}`), {\n            actual,\n            expected,\n        });\n    }\n}\nexport class Lazy {\n    constructor(factory) {\n        this.factory = factory;\n        this.isValueCreated = false;\n    }\n    get Value() {\n        if (!this.isValueCreated) {\n            this.createdValue = this.factory();\n            this.isValueCreated = true;\n        }\n        return this.createdValue;\n    }\n    get IsValueCreated() {\n        return this.isValueCreated;\n    }\n}\nexport function lazyFromValue(v) {\n    return new Lazy(() => v);\n}\nexport function padWithZeros(i, length) {\n    let str = i.toString(10);\n    while (str.length < length) {\n        str = \"0\" + str;\n    }\n    return str;\n}\nexport function padLeftAndRightWithZeros(i, lengthLeft, lengthRight) {\n    let str = i.toString(10);\n    while (str.length < lengthLeft) {\n        str = \"0\" + str;\n    }\n    while (str.length < lengthRight) {\n        str = str + \"0\";\n    }\n    return str;\n}\nexport function dateOffset(date) {\n    const date1 = date;\n    return typeof date1.offset === \"number\"\n        ? date1.offset\n        : (date.kind === 1 /* UTC */\n            ? 0 : date.getTimezoneOffset() * -60000);\n}\nexport function int16ToString(i, radix) {\n    i = i < 0 && radix != null && radix !== 10 ? 0xFFFF + i + 1 : i;\n    return i.toString(radix);\n}\nexport function int32ToString(i, radix) {\n    i = i < 0 && radix != null && radix !== 10 ? 0xFFFFFFFF + i + 1 : i;\n    return i.toString(radix);\n}\nexport class ObjectRef {\n    static id(o) {\n        if (!ObjectRef.idMap.has(o)) {\n            ObjectRef.idMap.set(o, ++ObjectRef.count);\n        }\n        return ObjectRef.idMap.get(o);\n    }\n}\nObjectRef.idMap = new WeakMap();\nObjectRef.count = 0;\nexport function stringHash(s) {\n    let i = 0;\n    let h = 5381;\n    const len = s.length;\n    while (i < len) {\n        h = (h * 33) ^ s.charCodeAt(i++);\n    }\n    return h;\n}\nexport function numberHash(x) {\n    return x * 2654435761 | 0;\n}\n// From https://stackoverflow.com/a/37449594\nexport function combineHashCodes(hashes) {\n    if (hashes.length === 0) {\n        return 0;\n    }\n    return hashes.reduce((h1, h2) => {\n        return ((h1 << 5) + h1) ^ h2;\n    });\n}\nexport function physicalHash(x) {\n    if (x == null) {\n        return 0;\n    }\n    switch (typeof x) {\n        case \"boolean\":\n            return x ? 1 : 0;\n        case \"number\":\n            return numberHash(x);\n        case \"string\":\n            return stringHash(x);\n        default:\n            return numberHash(ObjectRef.id(x));\n    }\n}\nexport function identityHash(x) {\n    if (x == null) {\n        return 0;\n    }\n    else if (isHashable(x)) {\n        return x.GetHashCode();\n    }\n    else {\n        return physicalHash(x);\n    }\n}\nexport function dateHash(x) {\n    return x.getTime();\n}\nexport function arrayHash(x) {\n    const len = x.length;\n    const hashes = new Array(len);\n    for (let i = 0; i < len; i++) {\n        hashes[i] = structuralHash(x[i]);\n    }\n    return combineHashCodes(hashes);\n}\nexport function structuralHash(x) {\n    if (x == null) {\n        return 0;\n    }\n    switch (typeof x) {\n        case \"boolean\":\n            return x ? 1 : 0;\n        case \"number\":\n            return numberHash(x);\n        case \"string\":\n            return stringHash(x);\n        default: {\n            if (isHashable(x)) {\n                return x.GetHashCode();\n            }\n            else if (isArrayLike(x)) {\n                return arrayHash(x);\n            }\n            else if (x instanceof Date) {\n                return dateHash(x);\n            }\n            else if (Object.getPrototypeOf(x).constructor === Object) {\n                // TODO: check call-stack to prevent cyclic objects?\n                const hashes = Object.values(x).map((v) => structuralHash(v));\n                return combineHashCodes(hashes);\n            }\n            else {\n                // Classes don't implement GetHashCode by default, but must use identity hashing\n                return numberHash(ObjectRef.id(x));\n                // return stringHash(String(x));\n            }\n        }\n    }\n}\n// Intended for custom numeric types, like long or decimal\nexport function fastStructuralHash(x) {\n    return stringHash(String(x));\n}\n// Intended for declared types that may or may not implement GetHashCode\nexport function safeHash(x) {\n    return x == null ? 0 : isHashable(x) ? x.GetHashCode() : numberHash(ObjectRef.id(x));\n}\nexport function equalArraysWith(x, y, eq) {\n    if (x == null) {\n        return y == null;\n    }\n    if (y == null) {\n        return false;\n    }\n    if (x.length !== y.length) {\n        return false;\n    }\n    for (let i = 0; i < x.length; i++) {\n        if (!eq(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}\nexport function equalArrays(x, y) {\n    return equalArraysWith(x, y, equals);\n}\nfunction equalObjects(x, y) {\n    const xKeys = Object.keys(x);\n    const yKeys = Object.keys(y);\n    if (xKeys.length !== yKeys.length) {\n        return false;\n    }\n    xKeys.sort();\n    yKeys.sort();\n    for (let i = 0; i < xKeys.length; i++) {\n        if (xKeys[i] !== yKeys[i] || !equals(x[xKeys[i]], y[yKeys[i]])) {\n            return false;\n        }\n    }\n    return true;\n}\nexport function equals(x, y) {\n    if (x === y) {\n        return true;\n    }\n    else if (x == null) {\n        return y == null;\n    }\n    else if (y == null) {\n        return false;\n    }\n    else if (typeof x !== \"object\") {\n        return false;\n    }\n    else if (isEquatable(x)) {\n        return x.Equals(y);\n    }\n    else if (isArrayLike(x)) {\n        return isArrayLike(y) && equalArrays(x, y);\n    }\n    else if (x instanceof Date) {\n        return (y instanceof Date) && compareDates(x, y) === 0;\n    }\n    else {\n        return Object.getPrototypeOf(x).constructor === Object && equalObjects(x, y);\n    }\n}\nexport function compareDates(x, y) {\n    let xtime;\n    let ytime;\n    // DateTimeOffset and DateTime deals with equality differently.\n    if (\"offset\" in x && \"offset\" in y) {\n        xtime = x.getTime();\n        ytime = y.getTime();\n    }\n    else {\n        xtime = x.getTime() + dateOffset(x);\n        ytime = y.getTime() + dateOffset(y);\n    }\n    return xtime === ytime ? 0 : (xtime < ytime ? -1 : 1);\n}\nexport function comparePrimitives(x, y) {\n    return x === y ? 0 : (x < y ? -1 : 1);\n}\nexport function compareArraysWith(x, y, comp) {\n    if (x == null) {\n        return y == null ? 0 : 1;\n    }\n    if (y == null) {\n        return -1;\n    }\n    if (x.length !== y.length) {\n        return x.length < y.length ? -1 : 1;\n    }\n    for (let i = 0, j = 0; i < x.length; i++) {\n        j = comp(x[i], y[i]);\n        if (j !== 0) {\n            return j;\n        }\n    }\n    return 0;\n}\nexport function compareArrays(x, y) {\n    return compareArraysWith(x, y, compare);\n}\nfunction compareObjects(x, y) {\n    const xKeys = Object.keys(x);\n    const yKeys = Object.keys(y);\n    if (xKeys.length !== yKeys.length) {\n        return xKeys.length < yKeys.length ? -1 : 1;\n    }\n    xKeys.sort();\n    yKeys.sort();\n    for (let i = 0, j = 0; i < xKeys.length; i++) {\n        const key = xKeys[i];\n        if (key !== yKeys[i]) {\n            return key < yKeys[i] ? -1 : 1;\n        }\n        else {\n            j = compare(x[key], y[key]);\n            if (j !== 0) {\n                return j;\n            }\n        }\n    }\n    return 0;\n}\nexport function compare(x, y) {\n    if (x === y) {\n        return 0;\n    }\n    else if (x == null) {\n        return y == null ? 0 : -1;\n    }\n    else if (y == null) {\n        return 1;\n    }\n    else if (typeof x !== \"object\") {\n        return x < y ? -1 : 1;\n    }\n    else if (isComparable(x)) {\n        return x.CompareTo(y);\n    }\n    else if (isArrayLike(x)) {\n        return isArrayLike(y) ? compareArrays(x, y) : -1;\n    }\n    else if (x instanceof Date) {\n        return y instanceof Date ? compareDates(x, y) : -1;\n    }\n    else {\n        return Object.getPrototypeOf(x).constructor === Object ? compareObjects(x, y) : -1;\n    }\n}\nexport function min(comparer, x, y) {\n    return comparer(x, y) < 0 ? x : y;\n}\nexport function max(comparer, x, y) {\n    return comparer(x, y) > 0 ? x : y;\n}\nexport function clamp(comparer, value, min, max) {\n    return (comparer(value, min) < 0) ? min : (comparer(value, max) > 0) ? max : value;\n}\nexport function createAtom(value) {\n    let atom = value;\n    return (value, isSetter) => {\n        if (!isSetter) {\n            return atom;\n        }\n        else {\n            atom = value;\n            return void 0;\n        }\n    };\n}\nexport function createObj(fields) {\n    const obj = {};\n    for (const kv of fields) {\n        obj[kv[0]] = kv[1];\n    }\n    return obj;\n}\nexport function jsOptions(mutator) {\n    const opts = {};\n    mutator(opts);\n    return opts;\n}\nexport function round(value, digits = 0) {\n    const m = Math.pow(10, digits);\n    const n = +(digits ? value * m : value).toFixed(8);\n    const i = Math.floor(n);\n    const f = n - i;\n    const e = 1e-8;\n    const r = (f > 0.5 - e && f < 0.5 + e) ? ((i % 2 === 0) ? i : i + 1) : Math.round(n);\n    return digits ? r / m : r;\n}\nexport function sign(x) {\n    return x > 0 ? 1 : x < 0 ? -1 : 0;\n}\nexport function randomNext(min, max) {\n    return Math.floor(Math.random() * (max - min)) + min;\n}\nexport function randomBytes(buffer) {\n    if (buffer == null) {\n        throw new Error(\"Buffer cannot be null\");\n    }\n    for (let i = 0; i < buffer.length; i += 6) {\n        // Pick random 48-bit number. Fill buffer in 2 24-bit chunks to avoid bitwise truncation.\n        let r = Math.floor(Math.random() * 281474976710656); // Low 24 bits = chunk 1.\n        const rhi = Math.floor(r / 16777216); // High 24 bits shifted via division = chunk 2.\n        for (let j = 0; j < 6 && i + j < buffer.length; j++) {\n            if (j === 3) {\n                r = rhi;\n            }\n            buffer[i + j] = r & 255;\n            r >>>= 8;\n        }\n    }\n}\nexport function unescapeDataString(s) {\n    // https://stackoverflow.com/a/4458580/524236\n    return decodeURIComponent((s).replace(/\\+/g, \"%20\"));\n}\nexport function escapeDataString(s) {\n    return encodeURIComponent(s).replace(/!/g, \"%21\")\n        .replace(/'/g, \"%27\")\n        .replace(/\\(/g, \"%28\")\n        .replace(/\\)/g, \"%29\")\n        .replace(/\\*/g, \"%2A\");\n}\nexport function escapeUriString(s) {\n    return encodeURI(s);\n}\n// ICollection.Clear and Count members can be called on Arrays\n// or Dictionaries so we need a runtime check (see #1120)\nexport function count(col) {\n    if (isArrayLike(col)) {\n        return col.length;\n    }\n    else {\n        let count = 0;\n        for (const _ of col) {\n            count++;\n        }\n        return count;\n    }\n}\nexport function clear(col) {\n    if (isArrayLike(col)) {\n        col.splice(0);\n    }\n    else {\n        col.clear();\n    }\n}\nconst CURRIED_KEY = \"__CURRIED__\";\nexport function uncurry(arity, f) {\n    // f may be a function option with None value\n    if (f == null || f.length > 1) {\n        return f;\n    }\n    let uncurriedFn;\n    switch (arity) {\n        case 2:\n            uncurriedFn = (a1, a2) => f(a1)(a2);\n            break;\n        case 3:\n            uncurriedFn = (a1, a2, a3) => f(a1)(a2)(a3);\n            break;\n        case 4:\n            uncurriedFn = (a1, a2, a3, a4) => f(a1)(a2)(a3)(a4);\n            break;\n        case 5:\n            uncurriedFn = (a1, a2, a3, a4, a5) => f(a1)(a2)(a3)(a4)(a5);\n            break;\n        case 6:\n            uncurriedFn = (a1, a2, a3, a4, a5, a6) => f(a1)(a2)(a3)(a4)(a5)(a6);\n            break;\n        case 7:\n            uncurriedFn = (a1, a2, a3, a4, a5, a6, a7) => f(a1)(a2)(a3)(a4)(a5)(a6)(a7);\n            break;\n        case 8:\n            uncurriedFn = (a1, a2, a3, a4, a5, a6, a7, a8) => f(a1)(a2)(a3)(a4)(a5)(a6)(a7)(a8);\n            break;\n        default:\n            throw new Error(\"Uncurrying to more than 8-arity is not supported: \" + arity);\n    }\n    uncurriedFn[CURRIED_KEY] = f;\n    return uncurriedFn;\n}\nexport function curry(arity, f) {\n    if (f == null || f.length === 1) {\n        return f;\n    }\n    if (CURRIED_KEY in f) {\n        return f[CURRIED_KEY];\n    }\n    switch (arity) {\n        case 2:\n            return (a1) => (a2) => f(a1, a2);\n        case 3:\n            return (a1) => (a2) => (a3) => f(a1, a2, a3);\n        case 4:\n            return (a1) => (a2) => (a3) => (a4) => f(a1, a2, a3, a4);\n        case 5:\n            return (a1) => (a2) => (a3) => (a4) => (a5) => f(a1, a2, a3, a4, a5);\n        case 6:\n            return (a1) => (a2) => (a3) => (a4) => (a5) => (a6) => f(a1, a2, a3, a4, a5, a6);\n        case 7:\n            return (a1) => (a2) => (a3) => (a4) => (a5) => (a6) => (a7) => f(a1, a2, a3, a4, a5, a6, a7);\n        case 8:\n            return (a1) => (a2) => (a3) => (a4) => (a5) => (a6) => (a7) => (a8) => f(a1, a2, a3, a4, a5, a6, a7, a8);\n        default:\n            throw new Error(\"Currying to more than 8-arity is not supported: \" + arity);\n    }\n}\nexport function checkArity(arity, f) {\n    return f.length > arity\n        ? (...args1) => (...args2) => f.apply(undefined, args1.concat(args2))\n        : f;\n}\nexport function partialApply(arity, f, args) {\n    if (f == null) {\n        return undefined;\n    }\n    else if (CURRIED_KEY in f) {\n        f = f[CURRIED_KEY];\n        for (let i = 0; i < args.length; i++) {\n            f = f(args[i]);\n        }\n        return f;\n    }\n    else {\n        switch (arity) {\n            case 1:\n                // Wrap arguments to make sure .concat doesn't destruct arrays. Example\n                // [1,2].concat([3,4],5)   --> [1,2,3,4,5]    // fails\n                // [1,2].concat([[3,4],5]) --> [1,2,[3,4],5]  // ok\n                return (a1) => f.apply(undefined, args.concat([a1]));\n            case 2:\n                return (a1) => (a2) => f.apply(undefined, args.concat([a1, a2]));\n            case 3:\n                return (a1) => (a2) => (a3) => f.apply(undefined, args.concat([a1, a2, a3]));\n            case 4:\n                return (a1) => (a2) => (a3) => (a4) => f.apply(undefined, args.concat([a1, a2, a3, a4]));\n            case 5:\n                return (a1) => (a2) => (a3) => (a4) => (a5) => f.apply(undefined, args.concat([a1, a2, a3, a4, a5]));\n            case 6:\n                return (a1) => (a2) => (a3) => (a4) => (a5) => (a6) => f.apply(undefined, args.concat([a1, a2, a3, a4, a5, a6]));\n            case 7:\n                return (a1) => (a2) => (a3) => (a4) => (a5) => (a6) => (a7) => f.apply(undefined, args.concat([a1, a2, a3, a4, a5, a6, a7]));\n            case 8:\n                return (a1) => (a2) => (a3) => (a4) => (a5) => (a6) => (a7) => (a8) => f.apply(undefined, args.concat([a1, a2, a3, a4, a5, a6, a7, a8]));\n            default:\n                throw new Error(\"Partially applying to more than 8-arity is not supported: \" + arity);\n        }\n    }\n}\nexport function mapCurriedArgs(fn, mappings) {\n    function mapArg(fn, arg, mappings, idx) {\n        const mapping = mappings[idx];\n        if (mapping !== 0) {\n            const expectedArity = mapping[0];\n            const actualArity = mapping[1];\n            if (expectedArity > 1) {\n                arg = curry(expectedArity, arg);\n            }\n            if (actualArity > 1) {\n                arg = uncurry(actualArity, arg);\n            }\n        }\n        const res = fn(arg);\n        if (idx + 1 === mappings.length) {\n            return res;\n        }\n        else {\n            return (arg) => mapArg(res, arg, mappings, idx + 1);\n        }\n    }\n    return (arg) => mapArg(fn, arg, mappings, 0);\n}\n","import { combineHashCodes, compare, compareArrays, equalArrays, equals, sameConstructor, numberHash, structuralHash } from \"./Util.js\";\nexport function seqToString(self) {\n    let count = 0;\n    let str = \"[\";\n    for (const x of self) {\n        if (count === 0) {\n            str += toString(x);\n        }\n        else if (count === 100) {\n            str += \"; ...\";\n            break;\n        }\n        else {\n            str += \"; \" + toString(x);\n        }\n        count++;\n    }\n    return str + \"]\";\n}\nexport function toString(x, callStack = 0) {\n    if (x != null && typeof x === \"object\") {\n        if (typeof x.toString === \"function\") {\n            return x.toString();\n        }\n        else if (Symbol.iterator in x) {\n            return seqToString(x);\n        }\n        else { // TODO: Date?\n            const cons = Object.getPrototypeOf(x).constructor;\n            return cons === Object && callStack < 10\n                // Same format as recordToString\n                ? \"{ \" + Object.entries(x).map(([k, v]) => k + \" = \" + toString(v, callStack + 1)).join(\"\\n  \") + \" }\"\n                : cons.name;\n        }\n    }\n    return String(x);\n}\nexport function unionToString(name, fields) {\n    if (fields.length === 0) {\n        return name;\n    }\n    else {\n        let fieldStr = \"\";\n        let withParens = true;\n        if (fields.length === 1) {\n            fieldStr = toString(fields[0]);\n            withParens = fieldStr.indexOf(\" \") >= 0;\n        }\n        else {\n            fieldStr = fields.map((x) => toString(x)).join(\", \");\n        }\n        return name + (withParens ? \" (\" : \" \") + fieldStr + (withParens ? \")\" : \"\");\n    }\n}\nexport class Union {\n    get name() {\n        return this.cases()[this.tag];\n    }\n    toJSON() {\n        return this.fields.length === 0 ? this.name : [this.name].concat(this.fields);\n    }\n    toString() {\n        return unionToString(this.name, this.fields);\n    }\n    GetHashCode() {\n        const hashes = this.fields.map((x) => structuralHash(x));\n        hashes.splice(0, 0, numberHash(this.tag));\n        return combineHashCodes(hashes);\n    }\n    Equals(other) {\n        if (this === other) {\n            return true;\n        }\n        else if (!sameConstructor(this, other)) {\n            return false;\n        }\n        else if (this.tag === other.tag) {\n            return equalArrays(this.fields, other.fields);\n        }\n        else {\n            return false;\n        }\n    }\n    CompareTo(other) {\n        if (this === other) {\n            return 0;\n        }\n        else if (!sameConstructor(this, other)) {\n            return -1;\n        }\n        else if (this.tag === other.tag) {\n            return compareArrays(this.fields, other.fields);\n        }\n        else {\n            return this.tag < other.tag ? -1 : 1;\n        }\n    }\n}\nfunction recordToJSON(self) {\n    const o = {};\n    const keys = Object.keys(self);\n    for (let i = 0; i < keys.length; i++) {\n        o[keys[i]] = self[keys[i]];\n    }\n    return o;\n}\nfunction recordToString(self) {\n    return \"{ \" + Object.entries(self).map(([k, v]) => k + \" = \" + toString(v)).join(\"\\n  \") + \" }\";\n}\nfunction recordGetHashCode(self) {\n    const hashes = Object.values(self).map((v) => structuralHash(v));\n    return combineHashCodes(hashes);\n}\nfunction recordEquals(self, other) {\n    if (self === other) {\n        return true;\n    }\n    else if (!sameConstructor(self, other)) {\n        return false;\n    }\n    else {\n        const thisNames = Object.keys(self);\n        for (let i = 0; i < thisNames.length; i++) {\n            if (!equals(self[thisNames[i]], other[thisNames[i]])) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\nfunction recordCompareTo(self, other) {\n    if (self === other) {\n        return 0;\n    }\n    else if (!sameConstructor(self, other)) {\n        return -1;\n    }\n    else {\n        const thisNames = Object.keys(self);\n        for (let i = 0; i < thisNames.length; i++) {\n            const result = compare(self[thisNames[i]], other[thisNames[i]]);\n            if (result !== 0) {\n                return result;\n            }\n        }\n        return 0;\n    }\n}\nexport class Record {\n    toJSON() { return recordToJSON(this); }\n    toString() { return recordToString(this); }\n    GetHashCode() { return recordGetHashCode(this); }\n    Equals(other) { return recordEquals(this, other); }\n    CompareTo(other) { return recordCompareTo(this, other); }\n}\nexport class FSharpRef {\n    constructor(contentsOrGetter, setter) {\n        if (typeof setter === \"function\") {\n            this.getter = contentsOrGetter;\n            this.setter = setter;\n        }\n        else {\n            this.getter = () => contentsOrGetter;\n            this.setter = (v) => { contentsOrGetter = v; };\n        }\n    }\n    get contents() {\n        return this.getter();\n    }\n    set contents(v) {\n        this.setter(v);\n    }\n}\n// EXCEPTIONS\n// Exception is intentionally not derived from Error, for performance reasons (see #2160)\nexport class Exception {\n    constructor(message) {\n        this.message = message;\n    }\n}\nexport function isException(x) {\n    return x instanceof Exception || x instanceof Error;\n}\nexport class FSharpException extends Exception {\n    toJSON() { return recordToJSON(this); }\n    toString() { return recordToString(this); }\n    GetHashCode() { return recordGetHashCode(this); }\n    Equals(other) { return recordEquals(this, other); }\n    CompareTo(other) { return recordCompareTo(this, other); }\n}\nexport class MatchFailureException extends FSharpException {\n    constructor(arg1, arg2, arg3) {\n        super();\n        this.arg1 = arg1;\n        this.arg2 = arg2 | 0;\n        this.arg3 = arg3 | 0;\n        this.message = \"The match cases were incomplete\";\n    }\n}\nexport class Attribute {\n}\n","// export type decimal = Decimal;\nexport var NumberStyles;\n(function (NumberStyles) {\n    // None = 0x00000000,\n    // AllowLeadingWhite = 0x00000001,\n    // AllowTrailingWhite = 0x00000002,\n    // AllowLeadingSign = 0x00000004,\n    // AllowTrailingSign = 0x00000008,\n    // AllowParentheses = 0x00000010,\n    // AllowDecimalPoint = 0x00000020,\n    // AllowThousands = 0x00000040,\n    // AllowExponent = 0x00000080,\n    // AllowCurrencySymbol = 0x00000100,\n    NumberStyles[NumberStyles[\"AllowHexSpecifier\"] = 512] = \"AllowHexSpecifier\";\n    // Integer = AllowLeadingWhite | AllowTrailingWhite | AllowLeadingSign,\n    // HexNumber = AllowLeadingWhite | AllowTrailingWhite | AllowHexSpecifier,\n    // Number = AllowLeadingWhite | AllowTrailingWhite | AllowLeadingSign |\n    //          AllowTrailingSign | AllowDecimalPoint | AllowThousands,\n    // Float = AllowLeadingWhite | AllowTrailingWhite | AllowLeadingSign |\n    //         AllowDecimalPoint | AllowExponent,\n    // Currency = AllowLeadingWhite | AllowTrailingWhite | AllowLeadingSign | AllowTrailingSign |\n    //            AllowParentheses | AllowDecimalPoint | AllowThousands | AllowCurrencySymbol,\n    // Any = AllowLeadingWhite | AllowTrailingWhite | AllowLeadingSign | AllowTrailingSign |\n    //       AllowParentheses | AllowDecimalPoint | AllowThousands | AllowCurrencySymbol | AllowExponent,\n})(NumberStyles || (NumberStyles = {}));\nfunction validResponse(regexMatch, radix) {\n    const [/*all*/ , sign, prefix, digits] = regexMatch;\n    return {\n        sign: sign || \"\",\n        prefix: prefix || \"\",\n        digits,\n        radix,\n    };\n}\nfunction getRange(unsigned, bitsize) {\n    switch (bitsize) {\n        case 8: return unsigned ? [0, 255] : [-128, 127];\n        case 16: return unsigned ? [0, 65535] : [-32768, 32767];\n        case 32: return unsigned ? [0, 4294967295] : [-2147483648, 2147483647];\n        default: throw new Error(\"Invalid bit size.\");\n    }\n}\nfunction getInvalidDigits(radix) {\n    switch (radix) {\n        case 2: return /[^0-1]/;\n        case 8: return /[^0-7]/;\n        case 10: return /[^0-9]/;\n        case 16: return /[^0-9a-fA-F]/;\n        default:\n            throw new Error(\"Invalid Base.\");\n    }\n}\nfunction getRadix(prefix, style) {\n    if (style & NumberStyles.AllowHexSpecifier) {\n        return 16;\n    }\n    else {\n        switch (prefix) {\n            case \"0b\":\n            case \"0B\": return 2;\n            case \"0o\":\n            case \"0O\": return 8;\n            case \"0x\":\n            case \"0X\": return 16;\n            default: return 10;\n        }\n    }\n}\nexport function isValid(str, style, radix) {\n    const integerRegex = /^\\s*([\\+\\-])?(0[xXoObB])?([0-9a-fA-F]+)\\s*$/;\n    const res = integerRegex.exec(str.replace(/_/g, \"\"));\n    if (res != null) {\n        const [/*all*/ , /*sign*/ , prefix, digits] = res;\n        radix = radix || getRadix(prefix, style);\n        const invalidDigits = getInvalidDigits(radix);\n        if (!invalidDigits.test(digits)) {\n            return validResponse(res, radix);\n        }\n    }\n    return null;\n}\nexport function parse(str, style, unsigned, bitsize, radix) {\n    const res = isValid(str, style, radix);\n    if (res != null) {\n        let v = Number.parseInt(res.sign + res.digits, res.radix);\n        if (!Number.isNaN(v)) {\n            const [umin, umax] = getRange(true, bitsize);\n            if (!unsigned && res.radix !== 10 && v >= umin && v <= umax) {\n                v = v << (32 - bitsize) >> (32 - bitsize);\n            }\n            const [min, max] = getRange(unsigned, bitsize);\n            if (v >= min && v <= max) {\n                return v;\n            }\n        }\n    }\n    throw new Error(\"Input string was not in a correct format.\");\n}\nexport function tryParse(str, style, unsigned, bitsize, defValue) {\n    try {\n        defValue.contents = parse(str, style, unsigned, bitsize);\n        return true;\n    }\n    catch (_a) {\n        return false;\n    }\n}\nexport function op_UnaryNegation_Int8(x) {\n    return x === -128 ? x : -x;\n}\nexport function op_UnaryNegation_Int16(x) {\n    return x === -32768 ? x : -x;\n}\nexport function op_UnaryNegation_Int32(x) {\n    return x === -2147483648 ? x : -x;\n}\n","export const symbol = Symbol(\"numeric\");\nexport function isNumeric(x) {\n    return typeof x === \"number\" || (x === null || x === void 0 ? void 0 : x[symbol]);\n}\nexport function compare(x, y) {\n    if (typeof x === \"number\") {\n        return x < y ? -1 : (x > y ? 1 : 0);\n    }\n    else {\n        return x.CompareTo(y);\n    }\n}\nexport function multiply(x, y) {\n    if (typeof x === \"number\") {\n        return x * y;\n    }\n    else {\n        return x[symbol]().multiply(y);\n    }\n}\nexport function toFixed(x, dp) {\n    if (typeof x === \"number\") {\n        return x.toFixed(dp);\n    }\n    else {\n        return x[symbol]().toFixed(dp);\n    }\n}\nexport function toPrecision(x, sd) {\n    if (typeof x === \"number\") {\n        return x.toPrecision(sd);\n    }\n    else {\n        return x[symbol]().toPrecision(sd);\n    }\n}\nexport function toExponential(x, dp) {\n    if (typeof x === \"number\") {\n        return x.toExponential(dp);\n    }\n    else {\n        return x[symbol]().toExponential(dp);\n    }\n}\nexport function toHex(x) {\n    if (typeof x === \"number\") {\n        return (Number(x) >>> 0).toString(16);\n    }\n    else {\n        return x[symbol]().toHex();\n    }\n}\n","// Adapted from: https://github.com/dcodeIO/long.js/blob/master/src/long.js\n// Apache License 2.0: https://github.com/dcodeIO/long.js/blob/master/LICENSE\n/* tslint:disable */\nimport { symbol } from \"../Numeric.js\";\n/**\n * wasm optimizations, to do native i64 multiplication and divide\n */\nvar wasm = null;\ntry {\n    wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([\n        0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11\n    ])), {}).exports;\n}\ncatch (e) {\n    // no wasm support :(\n}\n/**\n * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.\n *  See the from* functions below for more convenient ways of constructing Longs.\n * @exports Long\n * @class A Long class for representing a 64 bit two's-complement integer value.\n * @param {number} low The low (signed) 32 bits of the long\n * @param {number} high The high (signed) 32 bits of the long\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n * @constructor\n */\nexport function Long(low, high, unsigned) {\n    /**\n     * The low 32 bits as a signed value.\n     * @type {number}\n     */\n    this.low = low | 0;\n    /**\n     * The high 32 bits as a signed value.\n     * @type {number}\n     */\n    this.high = high | 0;\n    /**\n     * Whether unsigned or not.\n     * @type {boolean}\n     */\n    this.unsigned = !!unsigned;\n}\nLong.prototype.GetHashCode = function () {\n    let h1 = this.unsigned ? 1 : 0;\n    h1 = ((h1 << 5) + h1) ^ this.high;\n    h1 = ((h1 << 5) + h1) ^ this.low;\n    return h1;\n};\nLong.prototype.Equals = function (x) { return equals(this, x); };\nLong.prototype.CompareTo = function (x) { return compare(this, x); };\nLong.prototype.toString = function (radix) { return toString(this, radix); };\nLong.prototype.toJSON = function () { return toString(this); };\nLong.prototype[symbol] = function () {\n    const x = this;\n    return {\n        multiply: y => multiply(x, y),\n        toPrecision: sd => String(x) + (0).toPrecision(sd).substr(1),\n        toExponential: dp => String(x) + (0).toExponential(dp).substr(1),\n        toFixed: dp => String(x) + (0).toFixed(dp).substr(1),\n        toHex: () => toString(x.unsigned ? x : fromBytes(toBytes(x), true), 16),\n    };\n};\n// The internal representation of a long is the two given signed, 32-bit values.\n// We use 32-bit pieces because these are the size of integers on which\n// Javascript performs bit-operations.  For operations like addition and\n// multiplication, we split each number into 16 bit pieces, which can easily be\n// multiplied within Javascript's floating-point representation without overflow\n// or change in sign.\n//\n// In the algorithms below, we frequently reduce the negative case to the\n// positive case by negating the input(s) and then post-processing the result.\n// Note that we must ALWAYS check specially whether those values are MIN_VALUE\n// (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as\n// a positive number, it overflows back into a negative).  Not handling this\n// case would often result in infinite recursion.\n//\n// Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*\n// methods on which they depend.\n/**\n * An indicator used to reliably determine if an object is a Long or not.\n * @type {boolean}\n * @const\n * @private\n */\nLong.prototype.__isLong__;\nObject.defineProperty(Long.prototype, \"__isLong__\", { value: true });\n/**\n * @function\n * @param {*} obj Object\n * @returns {boolean}\n * @inner\n */\nexport function isLong(obj) {\n    return (obj && obj[\"__isLong__\"]) === true;\n}\n/**\n * Tests if the specified object is a Long.\n * @function\n * @param {*} obj Object\n * @returns {boolean}\n */\n// Long.isLong = isLong;\n/**\n * A cache of the Long representations of small integer values.\n * @type {!Object}\n * @inner\n */\nvar INT_CACHE = {};\n/**\n * A cache of the Long representations of small unsigned integer values.\n * @type {!Object}\n * @inner\n */\nvar UINT_CACHE = {};\n/**\n * @param {number} value\n * @param {boolean=} unsigned\n * @returns {!Long}\n * @inner\n */\nexport function fromInt(value, unsigned) {\n    var obj, cachedObj, cache;\n    if (unsigned) {\n        value >>>= 0;\n        if (cache = (0 <= value && value < 256)) {\n            cachedObj = UINT_CACHE[value];\n            if (cachedObj)\n                return cachedObj;\n        }\n        obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);\n        if (cache)\n            UINT_CACHE[value] = obj;\n        return obj;\n    }\n    else {\n        value |= 0;\n        if (cache = (-128 <= value && value < 128)) {\n            cachedObj = INT_CACHE[value];\n            if (cachedObj)\n                return cachedObj;\n        }\n        obj = fromBits(value, value < 0 ? -1 : 0, false);\n        if (cache)\n            INT_CACHE[value] = obj;\n        return obj;\n    }\n}\n/**\n * Returns a Long representing the given 32 bit integer value.\n * @function\n * @param {number} value The 32 bit integer in question\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n * @returns {!Long} The corresponding Long value\n */\n// Long.fromInt = fromInt;\n/**\n * @param {number} value\n * @param {boolean=} unsigned\n * @returns {!Long}\n * @inner\n */\nexport function fromNumber(value, unsigned) {\n    if (isNaN(value))\n        return unsigned ? UZERO : ZERO;\n    if (unsigned) {\n        if (value < 0)\n            return UZERO;\n        if (value >= TWO_PWR_64_DBL)\n            return MAX_UNSIGNED_VALUE;\n    }\n    else {\n        if (value <= -TWO_PWR_63_DBL)\n            return MIN_VALUE;\n        if (value + 1 >= TWO_PWR_63_DBL)\n            return MAX_VALUE;\n    }\n    if (value < 0)\n        return negate(fromNumber(-value, unsigned));\n    return fromBits((value % TWO_PWR_32_DBL) | 0, (value / TWO_PWR_32_DBL) | 0, unsigned);\n}\n/**\n * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.\n * @function\n * @param {number} value The number in question\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n * @returns {!Long} The corresponding Long value\n */\n// Long.fromNumber = fromNumber;\n/**\n * @param {number} lowBits\n * @param {number} highBits\n * @param {boolean=} unsigned\n * @returns {!Long}\n * @inner\n */\nexport function fromBits(lowBits, highBits, unsigned) {\n    return new Long(lowBits, highBits, unsigned);\n}\n/**\n * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is\n *  assumed to use 32 bits.\n * @function\n * @param {number} lowBits The low 32 bits\n * @param {number} highBits The high 32 bits\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n * @returns {!Long} The corresponding Long value\n */\n// Long.fromBits = fromBits;\n/**\n * @function\n * @param {number} base\n * @param {number} exponent\n * @returns {number}\n * @inner\n */\nvar pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)\n/**\n * @param {string} str\n * @param {(boolean|number)=} unsigned\n * @param {number=} radix\n * @returns {!Long}\n * @inner\n */\nexport function fromString(str, unsigned, radix) {\n    if (str.length === 0)\n        throw Error('empty string');\n    if (str === \"NaN\" || str === \"Infinity\" || str === \"+Infinity\" || str === \"-Infinity\")\n        return ZERO;\n    if (typeof unsigned === 'number') {\n        // For goog.math.long compatibility\n        radix = unsigned,\n            unsigned = false;\n    }\n    else {\n        unsigned = !!unsigned;\n    }\n    radix = radix || 10;\n    if (radix < 2 || 36 < radix)\n        throw RangeError('radix');\n    var p = str.indexOf('-');\n    if (p > 0)\n        throw Error('interior hyphen');\n    else if (p === 0) {\n        return negate(fromString(str.substring(1), unsigned, radix));\n    }\n    // Do several (8) digits each time through the loop, so as to\n    // minimize the calls to the very expensive emulated div.\n    var radixToPower = fromNumber(pow_dbl(radix, 8));\n    var result = ZERO;\n    for (var i = 0; i < str.length; i += 8) {\n        var size = Math.min(8, str.length - i), value = parseInt(str.substring(i, i + size), radix);\n        if (size < 8) {\n            var power = fromNumber(pow_dbl(radix, size));\n            result = add(multiply(result, power), fromNumber(value));\n        }\n        else {\n            result = multiply(result, radixToPower);\n            result = add(result, fromNumber(value));\n        }\n    }\n    result.unsigned = unsigned;\n    return result;\n}\n/**\n * Returns a Long representation of the given string, written using the specified radix.\n * @function\n * @param {string} str The textual representation of the Long\n * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to signed\n * @param {number=} radix The radix in which the text is written (2-36), defaults to 10\n * @returns {!Long} The corresponding Long value\n */\n// Long.fromString = fromString;\n/**\n * @function\n * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val\n * @param {boolean=} unsigned\n * @returns {!Long}\n * @inner\n */\nexport function fromValue(val, unsigned) {\n    if (typeof val === 'number')\n        return fromNumber(val, unsigned);\n    if (typeof val === 'string')\n        return fromString(val, unsigned);\n    // Throws for non-objects, converts non-instanceof Long:\n    return fromBits(val.low, val.high, typeof unsigned === 'boolean' ? unsigned : val.unsigned);\n}\n/**\n * Converts the specified value to a Long using the appropriate from* function for its type.\n * @function\n * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n * @returns {!Long}\n */\n// Long.fromValue = fromValue;\n// NOTE: the compiler should inline these constant values below and then remove these variables, so there should be\n// no runtime penalty for these.\n/**\n * @type {number}\n * @const\n * @inner\n */\nvar TWO_PWR_16_DBL = 1 << 16;\n/**\n * @type {number}\n * @const\n * @inner\n */\nvar TWO_PWR_24_DBL = 1 << 24;\n/**\n * @type {number}\n * @const\n * @inner\n */\nvar TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;\n/**\n * @type {number}\n * @const\n * @inner\n */\nvar TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;\n/**\n * @type {number}\n * @const\n * @inner\n */\nvar TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;\n/**\n * @type {!Long}\n * @const\n * @inner\n */\nvar TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);\n/**\n * @type {!Long}\n * @inner\n */\nexport var ZERO = fromInt(0);\n/**\n * Signed zero.\n * @type {!Long}\n */\n// Long.ZERO = ZERO;\n/**\n * @type {!Long}\n * @inner\n */\nexport var UZERO = fromInt(0, true);\n/**\n * Unsigned zero.\n * @type {!Long}\n */\n// Long.UZERO = UZERO;\n/**\n * @type {!Long}\n * @inner\n */\nexport var ONE = fromInt(1);\n/**\n * Signed one.\n * @type {!Long}\n */\n// Long.ONE = ONE;\n/**\n * @type {!Long}\n * @inner\n */\nexport var UONE = fromInt(1, true);\n/**\n * Unsigned one.\n * @type {!Long}\n */\n// Long.UONE = UONE;\n/**\n * @type {!Long}\n * @inner\n */\nexport var NEG_ONE = fromInt(-1);\n/**\n * Signed negative one.\n * @type {!Long}\n */\n// Long.NEG_ONE = NEG_ONE;\n/**\n * @type {!Long}\n * @inner\n */\nexport var MAX_VALUE = fromBits(0xFFFFFFFF | 0, 0x7FFFFFFF | 0, false);\n/**\n * Maximum signed value.\n * @type {!Long}\n */\n// Long.MAX_VALUE = MAX_VALUE;\n/**\n * @type {!Long}\n * @inner\n */\nexport var MAX_UNSIGNED_VALUE = fromBits(0xFFFFFFFF | 0, 0xFFFFFFFF | 0, true);\n/**\n * Maximum unsigned value.\n * @type {!Long}\n */\n// Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;\n/**\n * @type {!Long}\n * @inner\n */\nexport var MIN_VALUE = fromBits(0, 0x80000000 | 0, false);\n/**\n * Minimum signed value.\n * @type {!Long}\n */\n// Long.MIN_VALUE = MIN_VALUE;\n/**\n * @alias Long.prototype\n * @inner\n */\n// var LongPrototype = Long.prototype;\n/**\n * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.\n * @this {!Long}\n * @returns {number}\n */\nexport function toInt($this) {\n    return $this.unsigned ? $this.low >>> 0 : $this.low;\n}\n;\n/**\n * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).\n * @this {!Long}\n * @returns {number}\n */\nexport function toNumber($this) {\n    if ($this.unsigned)\n        return (($this.high >>> 0) * TWO_PWR_32_DBL) + ($this.low >>> 0);\n    return $this.high * TWO_PWR_32_DBL + ($this.low >>> 0);\n}\n;\n/**\n * Converts the Long to a string written in the specified radix.\n * @this {!Long}\n * @param {number=} radix Radix (2-36), defaults to 10\n * @returns {string}\n * @override\n * @throws {RangeError} If `radix` is out of range\n */\nexport function toString($this, radix) {\n    radix = radix || 10;\n    if (radix < 2 || 36 < radix)\n        throw RangeError('radix');\n    if (isZero($this))\n        return '0';\n    if (isNegative($this)) { // Unsigned Longs are never negative\n        if (equals($this, MIN_VALUE)) {\n            // We need to change the Long value before it can be negated, so we remove\n            // the bottom-most digit in this base and then recurse to do the rest.\n            var radixLong = fromNumber(radix), div = divide($this, radixLong), rem1 = subtract(multiply(div, radixLong), $this);\n            return toString(div, radix) + toInt(rem1).toString(radix);\n        }\n        else\n            return '-' + toString(negate($this), radix);\n    }\n    // Do several (6) digits each time through the loop, so as to\n    // minimize the calls to the very expensive emulated div.\n    var radixToPower = fromNumber(pow_dbl(radix, 6), $this.unsigned), rem = $this;\n    var result = '';\n    while (true) {\n        var remDiv = divide(rem, radixToPower), intval = toInt(subtract(rem, multiply(remDiv, radixToPower))) >>> 0, digits = intval.toString(radix);\n        rem = remDiv;\n        if (isZero(rem))\n            return digits + result;\n        else {\n            while (digits.length < 6)\n                digits = '0' + digits;\n            result = '' + digits + result;\n        }\n    }\n}\n;\n/**\n * Gets the high 32 bits as a signed integer.\n * @this {!Long}\n * @returns {number} Signed high bits\n */\nexport function getHighBits($this) {\n    return $this.high;\n}\n;\n/**\n * Gets the high 32 bits as an unsigned integer.\n * @this {!Long}\n * @returns {number} Unsigned high bits\n */\nexport function getHighBitsUnsigned($this) {\n    return $this.high >>> 0;\n}\n;\n/**\n * Gets the low 32 bits as a signed integer.\n * @this {!Long}\n * @returns {number} Signed low bits\n */\nexport function getLowBits($this) {\n    return $this.low;\n}\n;\n/**\n * Gets the low 32 bits as an unsigned integer.\n * @this {!Long}\n * @returns {number} Unsigned low bits\n */\nexport function getLowBitsUnsigned($this) {\n    return $this.low >>> 0;\n}\n;\n/**\n * Gets the number of bits needed to represent the absolute value of this Long.\n * @this {!Long}\n * @returns {number}\n */\nexport function getNumBitsAbs($this) {\n    if (isNegative($this)) // Unsigned Longs are never negative\n        return equals($this, MIN_VALUE) ? 64 : getNumBitsAbs(negate($this));\n    var val = $this.high != 0 ? $this.high : $this.low;\n    for (var bit = 31; bit > 0; bit--)\n        if ((val & (1 << bit)) != 0)\n            break;\n    return $this.high != 0 ? bit + 33 : bit + 1;\n}\n;\n/**\n * Tests if this Long's value equals zero.\n * @this {!Long}\n * @returns {boolean}\n */\nexport function isZero($this) {\n    return $this.high === 0 && $this.low === 0;\n}\n;\n/**\n * Tests if this Long's value equals zero. This is an alias of {@link Long#isZero}.\n * @returns {boolean}\n */\n// LongPrototype.eqz = LongPrototype.isZero;\n/**\n * Tests if this Long's value is negative.\n * @this {!Long}\n * @returns {boolean}\n */\nexport function isNegative($this) {\n    return !$this.unsigned && $this.high < 0;\n}\n;\n/**\n * Tests if this Long's value is positive.\n * @this {!Long}\n * @returns {boolean}\n */\nexport function isPositive($this) {\n    return $this.unsigned || $this.high >= 0;\n}\n;\n/**\n * Tests if this Long's value is odd.\n * @this {!Long}\n * @returns {boolean}\n */\nexport function isOdd($this) {\n    return ($this.low & 1) === 1;\n}\n;\n/**\n * Tests if this Long's value is even.\n * @this {!Long}\n * @returns {boolean}\n */\nexport function isEven($this) {\n    return ($this.low & 1) === 0;\n}\n;\n/**\n * Tests if this Long's value equals the specified's.\n * @this {!Long}\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\nexport function equals($this, other) {\n    if (!isLong(other))\n        other = fromValue(other);\n    if ($this.unsigned !== other.unsigned && ($this.high >>> 31) === 1 && (other.high >>> 31) === 1)\n        return false;\n    return $this.high === other.high && $this.low === other.low;\n}\n;\n/**\n * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.\n * @function\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\n// LongPrototype.eq = LongPrototype.equals;\n/**\n * Tests if this Long's value differs from the specified's.\n * @this {!Long}\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\nexport function notEquals($this, other) {\n    return !equals($this, /* validates */ other);\n}\n;\n/**\n * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.\n * @function\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\n// LongPrototype.neq = LongPrototype.notEquals;\n/**\n * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.\n * @function\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\n// LongPrototype.ne = LongPrototype.notEquals;\n/**\n * Tests if this Long's value is less than the specified's.\n * @this {!Long}\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\nexport function lessThan($this, other) {\n    return compare($this, /* validates */ other) < 0;\n}\n;\n/**\n * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.\n * @function\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\n// LongPrototype.lt = LongPrototype.lessThan;\n/**\n * Tests if this Long's value is less than or equal the specified's.\n * @this {!Long}\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\nexport function lessThanOrEqual($this, other) {\n    return compare($this, /* validates */ other) <= 0;\n}\n;\n/**\n * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.\n * @function\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\n// LongPrototype.lte = LongPrototype.lessThanOrEqual;\n/**\n * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.\n * @function\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\n// LongPrototype.le = LongPrototype.lessThanOrEqual;\n/**\n * Tests if this Long's value is greater than the specified's.\n * @this {!Long}\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\nexport function greaterThan($this, other) {\n    return compare($this, /* validates */ other) > 0;\n}\n;\n/**\n * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.\n * @function\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\n// LongPrototype.gt = LongPrototype.greaterThan;\n/**\n * Tests if this Long's value is greater than or equal the specified's.\n * @this {!Long}\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\nexport function greaterThanOrEqual($this, other) {\n    return compare($this, /* validates */ other) >= 0;\n}\n;\n/**\n * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.\n * @function\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\n// LongPrototype.gte = LongPrototype.greaterThanOrEqual;\n/**\n * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.\n * @function\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\n// LongPrototype.ge = LongPrototype.greaterThanOrEqual;\n/**\n * Compares this Long's value with the specified's.\n * @this {!Long}\n * @param {!Long|number|string} other Other value\n * @returns {number} 0 if they are the same, 1 if the this is greater and -1\n *  if the given one is greater\n */\nexport function compare($this, other) {\n    if (!isLong(other))\n        other = fromValue(other);\n    if (equals($this, other))\n        return 0;\n    var thisNeg = isNegative($this), otherNeg = isNegative(other);\n    if (thisNeg && !otherNeg)\n        return -1;\n    if (!thisNeg && otherNeg)\n        return 1;\n    // At this point the sign bits are the same\n    if (!$this.unsigned)\n        return isNegative(subtract($this, other)) ? -1 : 1;\n    // Both are positive if at least one is unsigned\n    return (other.high >>> 0) > ($this.high >>> 0) || (other.high === $this.high && (other.low >>> 0) > ($this.low >>> 0)) ? -1 : 1;\n}\n;\n/**\n * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.\n * @function\n * @param {!Long|number|string} other Other value\n * @returns {number} 0 if they are the same, 1 if the this is greater and -1\n *  if the given one is greater\n */\n// LongPrototype.comp = LongPrototype.compare;\n/**\n * Negates this Long's value.\n * @this {!Long}\n * @returns {!Long} Negated Long\n */\nexport function negate($this) {\n    if (!$this.unsigned && equals($this, MIN_VALUE))\n        return MIN_VALUE;\n    return add(not($this), ONE);\n}\n;\n/**\n * Negates this Long's value. This is an alias of {@link Long#negate}.\n * @function\n * @returns {!Long} Negated Long\n */\n// LongPrototype.neg = LongPrototype.negate;\n/**\n * Returns the sum of this and the specified Long.\n * @this {!Long}\n * @param {!Long|number|string} addend Addend\n * @returns {!Long} Sum\n */\nexport function add($this, addend) {\n    if (!isLong(addend))\n        addend = fromValue(addend);\n    // Divide each number into 4 chunks of 16 bits, and then sum the chunks.\n    var a48 = $this.high >>> 16;\n    var a32 = $this.high & 0xFFFF;\n    var a16 = $this.low >>> 16;\n    var a00 = $this.low & 0xFFFF;\n    var b48 = addend.high >>> 16;\n    var b32 = addend.high & 0xFFFF;\n    var b16 = addend.low >>> 16;\n    var b00 = addend.low & 0xFFFF;\n    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\n    c00 += a00 + b00;\n    c16 += c00 >>> 16;\n    c00 &= 0xFFFF;\n    c16 += a16 + b16;\n    c32 += c16 >>> 16;\n    c16 &= 0xFFFF;\n    c32 += a32 + b32;\n    c48 += c32 >>> 16;\n    c32 &= 0xFFFF;\n    c48 += a48 + b48;\n    c48 &= 0xFFFF;\n    return fromBits((c16 << 16) | c00, (c48 << 16) | c32, $this.unsigned);\n}\n;\n/**\n * Returns the difference of this and the specified Long.\n * @this {!Long}\n * @param {!Long|number|string} subtrahend Subtrahend\n * @returns {!Long} Difference\n */\nexport function subtract($this, subtrahend) {\n    if (!isLong(subtrahend))\n        subtrahend = fromValue(subtrahend);\n    return add($this, negate(subtrahend));\n}\n;\n/**\n * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.\n * @function\n * @param {!Long|number|string} subtrahend Subtrahend\n * @returns {!Long} Difference\n */\n// LongPrototype.sub = LongPrototype.subtract;\n/**\n * Returns the product of this and the specified Long.\n * @this {!Long}\n * @param {!Long|number|string} multiplier Multiplier\n * @returns {!Long} Product\n */\nexport function multiply($this, multiplier) {\n    if (isZero($this))\n        return $this.unsigned ? UZERO : ZERO;\n    if (!isLong(multiplier))\n        multiplier = fromValue(multiplier);\n    // use wasm support if present\n    if (wasm) {\n        var low = wasm.mul($this.low, $this.high, multiplier.low, multiplier.high);\n        return fromBits(low, wasm.get_high(), $this.unsigned);\n    }\n    if (isZero(multiplier))\n        return $this.unsigned ? UZERO : ZERO;\n    if (equals($this, MIN_VALUE))\n        return isOdd(multiplier) ? MIN_VALUE : ZERO;\n    if (equals(multiplier, MIN_VALUE))\n        return isOdd($this) ? MIN_VALUE : ZERO;\n    if (isNegative($this)) {\n        if (isNegative(multiplier))\n            return multiply(negate($this), negate(multiplier));\n        else\n            return negate(multiply(negate($this), multiplier));\n    }\n    else if (isNegative(multiplier))\n        return negate(multiply($this, negate(multiplier)));\n    // If both longs are small, use float multiplication\n    if (lessThan($this, TWO_PWR_24) && lessThan(multiplier, TWO_PWR_24))\n        return fromNumber(toNumber($this) * toNumber(multiplier), $this.unsigned);\n    // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.\n    // We can skip products that would overflow.\n    var a48 = $this.high >>> 16;\n    var a32 = $this.high & 0xFFFF;\n    var a16 = $this.low >>> 16;\n    var a00 = $this.low & 0xFFFF;\n    var b48 = multiplier.high >>> 16;\n    var b32 = multiplier.high & 0xFFFF;\n    var b16 = multiplier.low >>> 16;\n    var b00 = multiplier.low & 0xFFFF;\n    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\n    c00 += a00 * b00;\n    c16 += c00 >>> 16;\n    c00 &= 0xFFFF;\n    c16 += a16 * b00;\n    c32 += c16 >>> 16;\n    c16 &= 0xFFFF;\n    c16 += a00 * b16;\n    c32 += c16 >>> 16;\n    c16 &= 0xFFFF;\n    c32 += a32 * b00;\n    c48 += c32 >>> 16;\n    c32 &= 0xFFFF;\n    c32 += a16 * b16;\n    c48 += c32 >>> 16;\n    c32 &= 0xFFFF;\n    c32 += a00 * b32;\n    c48 += c32 >>> 16;\n    c32 &= 0xFFFF;\n    c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;\n    c48 &= 0xFFFF;\n    return fromBits((c16 << 16) | c00, (c48 << 16) | c32, $this.unsigned);\n}\n;\n/**\n * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.\n * @function\n * @param {!Long|number|string} multiplier Multiplier\n * @returns {!Long} Product\n */\n// LongPrototype.mul = LongPrototype.multiply;\n/**\n * Returns this Long divided by the specified. The result is signed if this Long is signed or\n *  unsigned if this Long is unsigned.\n * @this {!Long}\n * @param {!Long|number|string} divisor Divisor\n * @returns {!Long} Quotient\n */\nexport function divide($this, divisor) {\n    if (!isLong(divisor))\n        divisor = fromValue(divisor);\n    if (isZero(divisor))\n        throw Error('division by zero');\n    // use wasm support if present\n    if (wasm) {\n        // guard against signed division overflow: the largest\n        // negative number / -1 would be 1 larger than the largest\n        // positive number, due to two's complement.\n        if (!$this.unsigned &&\n            $this.high === -0x80000000 &&\n            divisor.low === -1 && divisor.high === -1) {\n            // be consistent with non-wasm code path\n            return $this;\n        }\n        var low = ($this.unsigned ? wasm.div_u : wasm.div_s)($this.low, $this.high, divisor.low, divisor.high);\n        return fromBits(low, wasm.get_high(), $this.unsigned);\n    }\n    if (isZero($this))\n        return $this.unsigned ? UZERO : ZERO;\n    var approx, rem, res;\n    if (!$this.unsigned) {\n        // This section is only relevant for signed longs and is derived from the\n        // closure library as a whole.\n        if (equals($this, MIN_VALUE)) {\n            if (equals(divisor, ONE) || equals(divisor, NEG_ONE))\n                return MIN_VALUE; // recall that -MIN_VALUE == MIN_VALUE\n            else if (equals(divisor, MIN_VALUE))\n                return ONE;\n            else {\n                // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.\n                var halfThis = shiftRight($this, 1);\n                approx = shiftLeft(divide(halfThis, divisor), 1);\n                if (equals(approx, ZERO)) {\n                    return isNegative(divisor) ? ONE : NEG_ONE;\n                }\n                else {\n                    rem = subtract($this, multiply(divisor, approx));\n                    res = add(approx, divide(rem, divisor));\n                    return res;\n                }\n            }\n        }\n        else if (equals(divisor, MIN_VALUE))\n            return $this.unsigned ? UZERO : ZERO;\n        if (isNegative($this)) {\n            if (isNegative(divisor))\n                return divide(negate($this), negate(divisor));\n            return negate(divide(negate($this), divisor));\n        }\n        else if (isNegative(divisor))\n            return negate(divide($this, negate(divisor)));\n        res = ZERO;\n    }\n    else {\n        // The algorithm below has not been made for unsigned longs. It's therefore\n        // required to take special care of the MSB prior to running it.\n        if (!divisor.unsigned)\n            divisor = toUnsigned(divisor);\n        if (greaterThan(divisor, $this))\n            return UZERO;\n        if (greaterThan(divisor, shiftRightUnsigned($this, 1))) // 15 >>> 1 = 7 ; with divisor = 8 ; true\n            return UONE;\n        res = UZERO;\n    }\n    // Repeat the following until the remainder is less than other:  find a\n    // floating-point that approximates remainder / other *from below*, add this\n    // into the result, and subtract it from the remainder.  It is critical that\n    // the approximate value is less than or equal to the real value so that the\n    // remainder never becomes negative.\n    rem = $this;\n    while (greaterThanOrEqual(rem, divisor)) {\n        // Approximate the result of division. This may be a little greater or\n        // smaller than the actual value.\n        approx = Math.max(1, Math.floor(toNumber(rem) / toNumber(divisor)));\n        // We will tweak the approximate result by changing it in the 48-th digit or\n        // the smallest non-fractional digit, whichever is larger.\n        var log2 = Math.ceil(Math.log(approx) / Math.LN2), delta = (log2 <= 48) ? 1 : pow_dbl(2, log2 - 48), \n        // Decrease the approximation until it is smaller than the remainder.  Note\n        // that if it is too large, the product overflows and is negative.\n        approxRes = fromNumber(approx), approxRem = multiply(approxRes, divisor);\n        while (isNegative(approxRem) || greaterThan(approxRem, rem)) {\n            approx -= delta;\n            approxRes = fromNumber(approx, $this.unsigned);\n            approxRem = multiply(approxRes, divisor);\n        }\n        // We know the answer can't be zero... and actually, zero would cause\n        // infinite recursion since we would make no progress.\n        if (isZero(approxRes))\n            approxRes = ONE;\n        res = add(res, approxRes);\n        rem = subtract(rem, approxRem);\n    }\n    return res;\n}\n;\n/**\n * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.\n * @function\n * @param {!Long|number|string} divisor Divisor\n * @returns {!Long} Quotient\n */\n// LongPrototype.div = LongPrototype.divide;\n/**\n * Returns this Long modulo the specified.\n * @this {!Long}\n * @param {!Long|number|string} divisor Divisor\n * @returns {!Long} Remainder\n */\nexport function modulo($this, divisor) {\n    if (!isLong(divisor))\n        divisor = fromValue(divisor);\n    // use wasm support if present\n    if (wasm) {\n        var low = ($this.unsigned ? wasm.rem_u : wasm.rem_s)($this.low, $this.high, divisor.low, divisor.high);\n        return fromBits(low, wasm.get_high(), $this.unsigned);\n    }\n    return subtract($this, multiply(divide($this, divisor), divisor));\n}\n;\n/**\n * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.\n * @function\n * @param {!Long|number|string} divisor Divisor\n * @returns {!Long} Remainder\n */\n// LongPrototype.mod = LongPrototype.modulo;\n/**\n * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.\n * @function\n * @param {!Long|number|string} divisor Divisor\n * @returns {!Long} Remainder\n */\n// LongPrototype.rem = LongPrototype.modulo;\n/**\n * Returns the bitwise NOT of this Long.\n * @this {!Long}\n * @returns {!Long}\n */\nexport function not($this) {\n    return fromBits(~$this.low, ~$this.high, $this.unsigned);\n}\n;\n/**\n * Returns the bitwise AND of this Long and the specified.\n * @this {!Long}\n * @param {!Long|number|string} other Other Long\n * @returns {!Long}\n */\nexport function and($this, other) {\n    if (!isLong(other))\n        other = fromValue(other);\n    return fromBits($this.low & other.low, $this.high & other.high, $this.unsigned);\n}\n;\n/**\n * Returns the bitwise OR of this Long and the specified.\n * @this {!Long}\n * @param {!Long|number|string} other Other Long\n * @returns {!Long}\n */\nexport function or($this, other) {\n    if (!isLong(other))\n        other = fromValue(other);\n    return fromBits($this.low | other.low, $this.high | other.high, $this.unsigned);\n}\n;\n/**\n * Returns the bitwise XOR of this Long and the given one.\n * @this {!Long}\n * @param {!Long|number|string} other Other Long\n * @returns {!Long}\n */\nexport function xor($this, other) {\n    if (!isLong(other))\n        other = fromValue(other);\n    return fromBits($this.low ^ other.low, $this.high ^ other.high, $this.unsigned);\n}\n;\n/**\n * Returns this Long with bits shifted to the left by the given amount.\n * @this {!Long}\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Shifted Long\n */\nexport function shiftLeft($this, numBits) {\n    if (isLong(numBits))\n        numBits = toInt(numBits);\n    if ((numBits &= 63) === 0)\n        return $this;\n    else if (numBits < 32)\n        return fromBits($this.low << numBits, ($this.high << numBits) | ($this.low >>> (32 - numBits)), $this.unsigned);\n    else\n        return fromBits(0, $this.low << (numBits - 32), $this.unsigned);\n}\n;\n/**\n * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.\n * @function\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Shifted Long\n */\n// LongPrototype.shl = LongPrototype.shiftLeft;\n/**\n * Returns this Long with bits arithmetically shifted to the right by the given amount.\n * @this {!Long}\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Shifted Long\n */\nexport function shiftRight($this, numBits) {\n    if (isLong(numBits))\n        numBits = toInt(numBits);\n    if ((numBits &= 63) === 0)\n        return $this;\n    else if (numBits < 32)\n        return fromBits(($this.low >>> numBits) | ($this.high << (32 - numBits)), $this.high >> numBits, $this.unsigned);\n    else\n        return fromBits($this.high >> (numBits - 32), $this.high >= 0 ? 0 : -1, $this.unsigned);\n}\n;\n/**\n * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.\n * @function\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Shifted Long\n */\n// LongPrototype.shr = LongPrototype.shiftRight;\n/**\n * Returns this Long with bits logically shifted to the right by the given amount.\n * @this {!Long}\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Shifted Long\n */\nexport function shiftRightUnsigned($this, numBits) {\n    if (isLong(numBits))\n        numBits = toInt(numBits);\n    numBits &= 63;\n    if (numBits === 0)\n        return $this;\n    else {\n        var high = $this.high;\n        if (numBits < 32) {\n            var low = $this.low;\n            return fromBits((low >>> numBits) | (high << (32 - numBits)), high >>> numBits, $this.unsigned);\n        }\n        else if (numBits === 32)\n            return fromBits(high, 0, $this.unsigned);\n        else\n            return fromBits(high >>> (numBits - 32), 0, $this.unsigned);\n    }\n}\n;\n/**\n * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.\n * @function\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Shifted Long\n */\n// LongPrototype.shru = LongPrototype.shiftRightUnsigned;\n/**\n * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.\n * @function\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Shifted Long\n */\n// LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;\n/**\n * Returns this Long with bits rotated to the left by the given amount.\n * @this {!Long}\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Rotated Long\n */\nexport const rotateLeft = function rotateLeft(numBits) {\n    var b;\n    if (isLong(numBits))\n        numBits = numBits.toInt();\n    if ((numBits &= 63) === 0)\n        return this;\n    if (numBits === 32)\n        return fromBits(this.high, this.low, this.unsigned);\n    if (numBits < 32) {\n        b = (32 - numBits);\n        return fromBits(((this.low << numBits) | (this.high >>> b)), ((this.high << numBits) | (this.low >>> b)), this.unsigned);\n    }\n    numBits -= 32;\n    b = (32 - numBits);\n    return fromBits(((this.high << numBits) | (this.low >>> b)), ((this.low << numBits) | (this.high >>> b)), this.unsigned);\n};\n/**\n * Returns this Long with bits rotated to the left by the given amount. This is an alias of {@link Long#rotateLeft}.\n * @function\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Rotated Long\n */\n// LongPrototype.rotl = LongPrototype.rotateLeft;\n/**\n * Returns this Long with bits rotated to the right by the given amount.\n * @this {!Long}\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Rotated Long\n */\nexport const rotateRight = function rotateRight(numBits) {\n    var b;\n    if (isLong(numBits))\n        numBits = numBits.toInt();\n    if ((numBits &= 63) === 0)\n        return this;\n    if (numBits === 32)\n        return fromBits(this.high, this.low, this.unsigned);\n    if (numBits < 32) {\n        b = (32 - numBits);\n        return fromBits(((this.high << b) | (this.low >>> numBits)), ((this.low << b) | (this.high >>> numBits)), this.unsigned);\n    }\n    numBits -= 32;\n    b = (32 - numBits);\n    return fromBits(((this.low << b) | (this.high >>> numBits)), ((this.high << b) | (this.low >>> numBits)), this.unsigned);\n};\n/**\n * Returns this Long with bits rotated to the right by the given amount. This is an alias of {@link Long#rotateRight}.\n * @function\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Rotated Long\n */\n// LongPrototype.rotr = LongPrototype.rotateRight;\n/**\n * Converts this Long to signed.\n * @this {!Long}\n * @returns {!Long} Signed long\n */\nexport function toSigned($this) {\n    if (!$this.unsigned)\n        return $this;\n    return fromBits($this.low, $this.high, false);\n}\n;\n/**\n * Converts this Long to unsigned.\n * @this {!Long}\n * @returns {!Long} Unsigned long\n */\nexport function toUnsigned($this) {\n    if ($this.unsigned)\n        return $this;\n    return fromBits($this.low, $this.high, true);\n}\n;\n/**\n * Converts this Long to its byte representation.\n * @param {boolean=} le Whether little or big endian, defaults to big endian\n * @this {!Long}\n * @returns {!Array.<number>} Byte representation\n */\nexport function toBytes($this, le) {\n    return le ? toBytesLE($this) : toBytesBE($this);\n}\n;\n/**\n * Converts this Long to its little endian byte representation.\n * @this {!Long}\n * @returns {!Array.<number>} Little endian byte representation\n */\nexport function toBytesLE($this) {\n    var hi = $this.high, lo = $this.low;\n    return [\n        lo & 0xff,\n        lo >>> 8 & 0xff,\n        lo >>> 16 & 0xff,\n        lo >>> 24,\n        hi & 0xff,\n        hi >>> 8 & 0xff,\n        hi >>> 16 & 0xff,\n        hi >>> 24\n    ];\n}\n;\n/**\n * Converts this Long to its big endian byte representation.\n * @this {!Long}\n * @returns {!Array.<number>} Big endian byte representation\n */\nexport function toBytesBE($this) {\n    var hi = $this.high, lo = $this.low;\n    return [\n        hi >>> 24,\n        hi >>> 16 & 0xff,\n        hi >>> 8 & 0xff,\n        hi & 0xff,\n        lo >>> 24,\n        lo >>> 16 & 0xff,\n        lo >>> 8 & 0xff,\n        lo & 0xff\n    ];\n}\n;\n/**\n * Creates a Long from its byte representation.\n * @param {!Array.<number>} bytes Byte representation\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n * @param {boolean=} le Whether little or big endian, defaults to big endian\n * @returns {Long} The corresponding Long value\n */\nexport function fromBytes(bytes, unsigned, le) {\n    return le ? fromBytesLE(bytes, unsigned) : fromBytesBE(bytes, unsigned);\n}\n;\n/**\n * Creates a Long from its little endian byte representation.\n * @param {!Array.<number>} bytes Little endian byte representation\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n * @returns {Long} The corresponding Long value\n */\nexport function fromBytesLE(bytes, unsigned) {\n    return new Long(bytes[0] |\n        bytes[1] << 8 |\n        bytes[2] << 16 |\n        bytes[3] << 24, bytes[4] |\n        bytes[5] << 8 |\n        bytes[6] << 16 |\n        bytes[7] << 24, unsigned);\n}\n;\n/**\n * Creates a Long from its big endian byte representation.\n * @param {!Array.<number>} bytes Big endian byte representation\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n * @returns {Long} The corresponding Long value\n */\nexport function fromBytesBE(bytes, unsigned) {\n    return new Long(bytes[4] << 24 |\n        bytes[5] << 16 |\n        bytes[6] << 8 |\n        bytes[7], bytes[0] << 24 |\n        bytes[1] << 16 |\n        bytes[2] << 8 |\n        bytes[3], unsigned);\n}\n;\n","/**\n * DateTimeOffset functions.\n *\n * Note: Date instances are always DateObjects in local\n * timezone (because JS dates are all kinds of messed up).\n * A local date returns UTC epoc when `.getTime()` is called.\n *\n * Basically; invariant: date.getTime() always return UTC time.\n */\nimport { fromValue, ticksToUnixEpochMilliseconds, unixEpochMillisecondsToTicks } from \"./Long.js\";\nimport { compareDates, dateOffset, padWithZeros } from \"./Util.js\";\nexport const offsetRegex = /(?:Z|[+-](\\d+):?([0-5]?\\d)?)\\s*$/;\nexport function dateOffsetToString(offset) {\n    const isMinus = offset < 0;\n    offset = Math.abs(offset);\n    const hours = ~~(offset / 3600000);\n    const minutes = (offset % 3600000) / 60000;\n    return (isMinus ? \"-\" : \"+\") +\n        padWithZeros(hours, 2) + \":\" +\n        padWithZeros(minutes, 2);\n}\nexport function dateToHalfUTCString(date, half) {\n    const str = date.toISOString();\n    return half === \"first\"\n        ? str.substring(0, str.indexOf(\"T\"))\n        : str.substring(str.indexOf(\"T\") + 1, str.length - 1);\n}\nfunction dateToISOString(d, utc) {\n    if (utc) {\n        return d.toISOString();\n    }\n    else {\n        // JS Date is always local\n        const printOffset = d.kind == null ? true : d.kind === 2 /* Local */;\n        return padWithZeros(d.getFullYear(), 4) + \"-\" +\n            padWithZeros(d.getMonth() + 1, 2) + \"-\" +\n            padWithZeros(d.getDate(), 2) + \"T\" +\n            padWithZeros(d.getHours(), 2) + \":\" +\n            padWithZeros(d.getMinutes(), 2) + \":\" +\n            padWithZeros(d.getSeconds(), 2) + \".\" +\n            padWithZeros(d.getMilliseconds(), 3) +\n            (printOffset ? dateOffsetToString(d.getTimezoneOffset() * -60000) : \"\");\n    }\n}\nfunction dateToISOStringWithOffset(dateWithOffset, offset) {\n    const str = dateWithOffset.toISOString();\n    return str.substring(0, str.length - 1) + dateOffsetToString(offset);\n}\nfunction dateToStringWithCustomFormat(date, format, utc) {\n    return format.replace(/(\\w)\\1*/g, (match) => {\n        let rep = Number.NaN;\n        switch (match.substring(0, 1)) {\n            case \"y\":\n                const y = utc ? date.getUTCFullYear() : date.getFullYear();\n                rep = match.length < 4 ? y % 100 : y;\n                break;\n            case \"M\":\n                rep = (utc ? date.getUTCMonth() : date.getMonth()) + 1;\n                break;\n            case \"d\":\n                rep = utc ? date.getUTCDate() : date.getDate();\n                break;\n            case \"H\":\n                rep = utc ? date.getUTCHours() : date.getHours();\n                break;\n            case \"h\":\n                const h = utc ? date.getUTCHours() : date.getHours();\n                rep = h > 12 ? h % 12 : h;\n                break;\n            case \"m\":\n                rep = utc ? date.getUTCMinutes() : date.getMinutes();\n                break;\n            case \"s\":\n                rep = utc ? date.getUTCSeconds() : date.getSeconds();\n                break;\n            case \"f\":\n                rep = utc ? date.getUTCMilliseconds() : date.getMilliseconds();\n                break;\n        }\n        if (Number.isNaN(rep)) {\n            return match;\n        }\n        else {\n            return (rep < 10 && match.length > 1) ? \"0\" + rep : \"\" + rep;\n        }\n    });\n}\nfunction dateToStringWithOffset(date, format) {\n    var _a, _b, _c;\n    const d = new Date(date.getTime() + ((_a = date.offset) !== null && _a !== void 0 ? _a : 0));\n    if (typeof format !== \"string\") {\n        return d.toISOString().replace(/\\.\\d+/, \"\").replace(/[A-Z]|\\.\\d+/g, \" \") + dateOffsetToString(((_b = date.offset) !== null && _b !== void 0 ? _b : 0));\n    }\n    else if (format.length === 1) {\n        switch (format) {\n            case \"D\":\n            case \"d\": return dateToHalfUTCString(d, \"first\");\n            case \"T\":\n            case \"t\": return dateToHalfUTCString(d, \"second\");\n            case \"O\":\n            case \"o\": return dateToISOStringWithOffset(d, ((_c = date.offset) !== null && _c !== void 0 ? _c : 0));\n            default: throw new Error(\"Unrecognized Date print format\");\n        }\n    }\n    else {\n        return dateToStringWithCustomFormat(d, format, true);\n    }\n}\nfunction dateToStringWithKind(date, format) {\n    const utc = date.kind === 1 /* UTC */;\n    if (typeof format !== \"string\") {\n        return utc ? date.toUTCString() : date.toLocaleString();\n    }\n    else if (format.length === 1) {\n        switch (format) {\n            case \"D\":\n            case \"d\":\n                return utc ? dateToHalfUTCString(date, \"first\") : date.toLocaleDateString();\n            case \"T\":\n            case \"t\":\n                return utc ? dateToHalfUTCString(date, \"second\") : date.toLocaleTimeString();\n            case \"O\":\n            case \"o\":\n                return dateToISOString(date, utc);\n            default:\n                throw new Error(\"Unrecognized Date print format\");\n        }\n    }\n    else {\n        return dateToStringWithCustomFormat(date, format, utc);\n    }\n}\nexport function toString(date, format, _provider) {\n    return date.offset != null\n        ? dateToStringWithOffset(date, format)\n        : dateToStringWithKind(date, format);\n}\nexport function DateTime(value, kind) {\n    const d = new Date(value);\n    d.kind = (kind == null ? 0 /* Unspecified */ : kind) | 0;\n    return d;\n}\nexport function fromTicks(ticks, kind) {\n    ticks = fromValue(ticks);\n    kind = kind != null ? kind : 0 /* Unspecified */;\n    let date = DateTime(ticksToUnixEpochMilliseconds(ticks), kind);\n    // Ticks are local to offset (in this case, either UTC or Local/Unknown).\n    // If kind is anything but UTC, that means that the tick number was not\n    // in utc, thus getTime() cannot return UTC, and needs to be shifted.\n    if (kind !== 1 /* UTC */) {\n        date = DateTime(date.getTime() - dateOffset(date), kind);\n    }\n    return date;\n}\nexport function fromDateTimeOffset(date, kind) {\n    var _a;\n    switch (kind) {\n        case 1 /* UTC */: return DateTime(date.getTime(), 1 /* UTC */);\n        case 2 /* Local */: return DateTime(date.getTime(), 2 /* Local */);\n        default:\n            const d = DateTime(date.getTime() + ((_a = date.offset) !== null && _a !== void 0 ? _a : 0), kind);\n            return DateTime(d.getTime() - dateOffset(d), kind);\n    }\n}\nexport function getTicks(date) {\n    return unixEpochMillisecondsToTicks(date.getTime(), dateOffset(date));\n}\nexport function minValue() {\n    // This is \"0001-01-01T00:00:00.000Z\", actual JS min value is -8640000000000000\n    return DateTime(-62135596800000, 0 /* Unspecified */);\n}\nexport function maxValue() {\n    // This is \"9999-12-31T23:59:59.999Z\", actual JS max value is 8640000000000000\n    return DateTime(253402300799999, 0 /* Unspecified */);\n}\nexport function parseRaw(input) {\n    if (input === null) {\n        throw new Error(\"Value cannot be null when parsing DateTime\");\n    }\n    if (input.trim() === \"\") {\n        throw new Error(\"An empty string is not recognized as a valid DateTime\");\n    }\n    let date = new Date(input);\n    if (isNaN(date.getTime())) {\n        // Try to check strings JS Date cannot parse (see #1045, #1422)\n        // tslint:disable-next-line:max-line-length\n        const m = /^\\s*(\\d+[^\\w\\s:]\\d+[^\\w\\s:]\\d+)?\\s*(\\d+:\\d+(?::\\d+(?:\\.\\d+)?)?)?\\s*([AaPp][Mm])?\\s*([+-]\\d+(?::\\d+)?)?\\s*$/.exec(input);\n        if (m != null) {\n            let baseDate;\n            let timeInSeconds = 0;\n            if (m[2] != null) {\n                const timeParts = m[2].split(\":\");\n                timeInSeconds =\n                    parseInt(timeParts[0], 10) * 3600 +\n                        parseInt(timeParts[1] || \"0\", 10) * 60 +\n                        parseFloat(timeParts[2] || \"0\");\n                if (m[3] != null && m[3].toUpperCase() === \"PM\") {\n                    timeInSeconds += 720;\n                }\n            }\n            if (m[4] != null) { // There's an offset, parse as UTC\n                if (m[1] != null) {\n                    baseDate = new Date(m[1] + \" UTC\");\n                }\n                else {\n                    const d = new Date();\n                    baseDate = new Date(d.getUTCFullYear() + \"/\" + (d.getUTCMonth() + 1) + \"/\" + d.getUTCDate());\n                }\n                const offsetParts = m[4].substr(1).split(\":\");\n                let offsetInMinutes = parseInt(offsetParts[0], 10) * 60 + parseInt(offsetParts[1] || \"0\", 10);\n                if (m[4][0] === \"+\") {\n                    offsetInMinutes *= -1;\n                }\n                timeInSeconds += offsetInMinutes * 60;\n            }\n            else {\n                if (m[1] != null) {\n                    baseDate = new Date(m[1]);\n                }\n                else {\n                    const d = new Date();\n                    baseDate = new Date(d.getFullYear() + \"/\" + (d.getMonth() + 1) + \"/\" + d.getDate());\n                }\n            }\n            date = new Date(baseDate.getTime() + timeInSeconds * 1000);\n            // correct for daylight savings time\n            date = new Date(date.getTime() + (date.getTimezoneOffset() - baseDate.getTimezoneOffset()) * 60000);\n        }\n        else {\n            throw new Error(\"The string is not a valid Date.\");\n        }\n    }\n    return date;\n}\nexport function parse(str, detectUTC = false) {\n    const date = parseRaw(str);\n    const offset = offsetRegex.exec(str);\n    // .NET always parses DateTime as Local if there's offset info (even \"Z\")\n    // Newtonsoft.Json uses UTC if the offset is \"Z\"\n    const kind = offset != null\n        ? (detectUTC && offset[0] === \"Z\" ? 1 /* UTC */ : 2 /* Local */)\n        : 0 /* Unspecified */;\n    return DateTime(date.getTime(), kind);\n}\nexport function tryParse(v, defValue) {\n    try {\n        defValue.contents = parse(v);\n        return true;\n    }\n    catch (_err) {\n        return false;\n    }\n}\nexport function create(year, month, day, h = 0, m = 0, s = 0, ms = 0, kind) {\n    const dateValue = kind === 1 /* UTC */\n        ? Date.UTC(year, month - 1, day, h, m, s, ms)\n        : new Date(year, month - 1, day, h, m, s, ms).getTime();\n    if (isNaN(dateValue)) {\n        throw new Error(\"The parameters describe an unrepresentable Date.\");\n    }\n    const date = DateTime(dateValue, kind);\n    if (year <= 99) {\n        date.setFullYear(year, month - 1, day);\n    }\n    return date;\n}\nexport function now() {\n    return DateTime(Date.now(), 2 /* Local */);\n}\nexport function utcNow() {\n    return DateTime(Date.now(), 1 /* UTC */);\n}\nexport function today() {\n    return date(now());\n}\nexport function isLeapYear(year) {\n    return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;\n}\nexport function daysInMonth(year, month) {\n    return month === 2\n        ? (isLeapYear(year) ? 29 : 28)\n        : (month >= 8 ? (month % 2 === 0 ? 31 : 30) : (month % 2 === 0 ? 30 : 31));\n}\nexport function toUniversalTime(date) {\n    return date.kind === 1 /* UTC */ ? date : DateTime(date.getTime(), 1 /* UTC */);\n}\nexport function toLocalTime(date) {\n    return date.kind === 2 /* Local */ ? date : DateTime(date.getTime(), 2 /* Local */);\n}\nexport function specifyKind(d, kind) {\n    return create(year(d), month(d), day(d), hour(d), minute(d), second(d), millisecond(d), kind);\n}\nexport function timeOfDay(d) {\n    return hour(d) * 3600000\n        + minute(d) * 60000\n        + second(d) * 1000\n        + millisecond(d);\n}\nexport function date(d) {\n    return create(year(d), month(d), day(d), 0, 0, 0, 0, d.kind);\n}\nexport function day(d) {\n    return d.kind === 1 /* UTC */ ? d.getUTCDate() : d.getDate();\n}\nexport function hour(d) {\n    return d.kind === 1 /* UTC */ ? d.getUTCHours() : d.getHours();\n}\nexport function millisecond(d) {\n    return d.kind === 1 /* UTC */ ? d.getUTCMilliseconds() : d.getMilliseconds();\n}\nexport function minute(d) {\n    return d.kind === 1 /* UTC */ ? d.getUTCMinutes() : d.getMinutes();\n}\nexport function month(d) {\n    return (d.kind === 1 /* UTC */ ? d.getUTCMonth() : d.getMonth()) + 1;\n}\nexport function second(d) {\n    return d.kind === 1 /* UTC */ ? d.getUTCSeconds() : d.getSeconds();\n}\nexport function year(d) {\n    return d.kind === 1 /* UTC */ ? d.getUTCFullYear() : d.getFullYear();\n}\nexport function dayOfWeek(d) {\n    return d.kind === 1 /* UTC */ ? d.getUTCDay() : d.getDay();\n}\nexport function dayOfYear(d) {\n    const _year = year(d);\n    const _month = month(d);\n    let _day = day(d);\n    for (let i = 1; i < _month; i++) {\n        _day += daysInMonth(_year, i);\n    }\n    return _day;\n}\nexport function add(d, ts) {\n    const newDate = DateTime(d.getTime() + ts, d.kind);\n    if (d.kind === 2 /* Local */) {\n        const oldTzOffset = d.getTimezoneOffset();\n        const newTzOffset = newDate.getTimezoneOffset();\n        return oldTzOffset !== newTzOffset\n            ? DateTime(newDate.getTime() + (newTzOffset - oldTzOffset) * 60000, d.kind)\n            : newDate;\n    }\n    else {\n        return newDate;\n    }\n}\nexport function addDays(d, v) {\n    return add(d, v * 86400000);\n}\nexport function addHours(d, v) {\n    return add(d, v * 3600000);\n}\nexport function addMinutes(d, v) {\n    return add(d, v * 60000);\n}\nexport function addSeconds(d, v) {\n    return add(d, v * 1000);\n}\nexport function addMilliseconds(d, v) {\n    return add(d, v);\n}\nexport function addYears(d, v) {\n    const newMonth = month(d);\n    const newYear = year(d) + v;\n    const _daysInMonth = daysInMonth(newYear, newMonth);\n    const newDay = Math.min(_daysInMonth, day(d));\n    return create(newYear, newMonth, newDay, hour(d), minute(d), second(d), millisecond(d), d.kind);\n}\nexport function addMonths(d, v) {\n    let newMonth = month(d) + v;\n    let newMonth_ = 0;\n    let yearOffset = 0;\n    if (newMonth > 12) {\n        newMonth_ = newMonth % 12;\n        yearOffset = Math.floor(newMonth / 12);\n        newMonth = newMonth_;\n    }\n    else if (newMonth < 1) {\n        newMonth_ = 12 + newMonth % 12;\n        yearOffset = Math.floor(newMonth / 12) + (newMonth_ === 12 ? -1 : 0);\n        newMonth = newMonth_;\n    }\n    const newYear = year(d) + yearOffset;\n    const _daysInMonth = daysInMonth(newYear, newMonth);\n    const newDay = Math.min(_daysInMonth, day(d));\n    return create(newYear, newMonth, newDay, hour(d), minute(d), second(d), millisecond(d), d.kind);\n}\nexport function subtract(d, that) {\n    return typeof that === \"number\"\n        ? add(d, -that)\n        : d.getTime() - that.getTime();\n}\nexport function toLongDateString(d) {\n    return d.toDateString();\n}\nexport function toShortDateString(d) {\n    return d.toLocaleDateString();\n}\nexport function toLongTimeString(d) {\n    return d.toLocaleTimeString();\n}\nexport function toShortTimeString(d) {\n    return d.toLocaleTimeString().replace(/:\\d\\d(?!:)/, \"\");\n}\nexport function equals(d1, d2) {\n    return d1.getTime() === d2.getTime();\n}\nexport const compare = compareDates;\nexport const compareTo = compareDates;\nexport function op_Addition(x, y) {\n    return add(x, y);\n}\nexport function op_Subtraction(x, y) {\n    return subtract(x, y);\n}\nexport function isDaylightSavingTime(x) {\n    const jan = new Date(x.getFullYear(), 0, 1);\n    const jul = new Date(x.getFullYear(), 6, 1);\n    return isDST(jan.getTimezoneOffset(), jul.getTimezoneOffset(), x.getTimezoneOffset());\n}\nfunction isDST(janOffset, julOffset, tOffset) {\n    return Math.min(janOffset, julOffset) === tOffset;\n}\nexport default DateTime;\n","import { toString as dateToString } from \"./Date.js\";\nimport { compare as numericCompare, isNumeric, multiply, toExponential, toFixed, toHex, toPrecision } from \"./Numeric.js\";\nimport { escape } from \"./RegExp.js\";\nimport { toString } from \"./Types.js\";\nconst fsFormatRegExp = /(^|[^%])%([0+\\- ]*)(\\*|\\d+)?(?:\\.(\\d+))?(\\w)/g;\nconst interpolateRegExp = /(?:(^|[^%])%([0+\\- ]*)(\\d+)?(?:\\.(\\d+))?(\\w))?%P\\(\\)/g;\nconst formatRegExp = /\\{(\\d+)(,-?\\d+)?(?:\\:([a-zA-Z])(\\d{0,2})|\\:(.+?))?\\}/g;\nfunction isLessThan(x, y) {\n    return numericCompare(x, y) < 0;\n}\nfunction cmp(x, y, ic) {\n    function isIgnoreCase(i) {\n        return i === true ||\n            i === 1 /* CurrentCultureIgnoreCase */ ||\n            i === 3 /* InvariantCultureIgnoreCase */ ||\n            i === 5 /* OrdinalIgnoreCase */;\n    }\n    function isOrdinal(i) {\n        return i === 4 /* Ordinal */ ||\n            i === 5 /* OrdinalIgnoreCase */;\n    }\n    if (x == null) {\n        return y == null ? 0 : -1;\n    }\n    if (y == null) {\n        return 1;\n    } // everything is bigger than null\n    if (isOrdinal(ic)) {\n        if (isIgnoreCase(ic)) {\n            x = x.toLowerCase();\n            y = y.toLowerCase();\n        }\n        return (x === y) ? 0 : (x < y ? -1 : 1);\n    }\n    else {\n        if (isIgnoreCase(ic)) {\n            x = x.toLocaleLowerCase();\n            y = y.toLocaleLowerCase();\n        }\n        return x.localeCompare(y);\n    }\n}\nexport function compare(...args) {\n    switch (args.length) {\n        case 2: return cmp(args[0], args[1], false);\n        case 3: return cmp(args[0], args[1], args[2]);\n        case 4: return cmp(args[0], args[1], args[2] === true);\n        case 5: return cmp(args[0].substr(args[1], args[4]), args[2].substr(args[3], args[4]), false);\n        case 6: return cmp(args[0].substr(args[1], args[4]), args[2].substr(args[3], args[4]), args[5]);\n        case 7: return cmp(args[0].substr(args[1], args[4]), args[2].substr(args[3], args[4]), args[5] === true);\n        default: throw new Error(\"String.compare: Unsupported number of parameters\");\n    }\n}\nexport function compareOrdinal(x, y) {\n    return cmp(x, y, 4 /* Ordinal */);\n}\nexport function compareTo(x, y) {\n    return cmp(x, y, 0 /* CurrentCulture */);\n}\nexport function startsWith(str, pattern, ic) {\n    if (str.length >= pattern.length) {\n        return cmp(str.substr(0, pattern.length), pattern, ic) === 0;\n    }\n    return false;\n}\nexport function indexOfAny(str, anyOf, ...args) {\n    if (str == null || str === \"\") {\n        return -1;\n    }\n    const startIndex = (args.length > 0) ? args[0] : 0;\n    if (startIndex < 0) {\n        throw new Error(\"Start index cannot be negative\");\n    }\n    const length = (args.length > 1) ? args[1] : str.length - startIndex;\n    if (length < 0) {\n        throw new Error(\"Length cannot be negative\");\n    }\n    if (length > str.length - startIndex) {\n        throw new Error(\"Invalid startIndex and length\");\n    }\n    str = str.substr(startIndex, length);\n    for (const c of anyOf) {\n        const index = str.indexOf(c);\n        if (index > -1) {\n            return index + startIndex;\n        }\n    }\n    return -1;\n}\nexport function printf(input) {\n    return {\n        input,\n        cont: fsFormat(input),\n    };\n}\nexport function interpolate(str, values) {\n    let valIdx = 0;\n    let strIdx = 0;\n    let result = \"\";\n    interpolateRegExp.lastIndex = 0;\n    let match = interpolateRegExp.exec(str);\n    while (match) {\n        // The first group corresponds to the no-escape char (^|[^%]), the actual pattern starts in the next char\n        // Note: we don't use negative lookbehind because some browsers don't support it yet\n        const matchIndex = match.index + (match[1] || \"\").length;\n        result += str.substring(strIdx, matchIndex).replace(/%%/g, \"%\");\n        const [, , flags, padLength, precision, format] = match;\n        result += formatReplacement(values[valIdx++], flags, padLength, precision, format);\n        strIdx = interpolateRegExp.lastIndex;\n        // Likewise we need to move interpolateRegExp.lastIndex one char behind to make sure we match the no-escape char next time\n        interpolateRegExp.lastIndex -= 1;\n        match = interpolateRegExp.exec(str);\n    }\n    result += str.substring(strIdx).replace(/%%/g, \"%\");\n    return result;\n}\nfunction continuePrint(cont, arg) {\n    return typeof arg === \"string\" ? cont(arg) : arg.cont(cont);\n}\nexport function toConsole(arg) {\n    // Don't remove the lambda here, see #1357\n    return continuePrint((x) => console.log(x), arg);\n}\nexport function toConsoleError(arg) {\n    return continuePrint((x) => console.error(x), arg);\n}\nexport function toText(arg) {\n    return continuePrint((x) => x, arg);\n}\nexport function toFail(arg) {\n    return continuePrint((x) => {\n        throw new Error(x);\n    }, arg);\n}\nfunction formatReplacement(rep, flags, padLength, precision, format) {\n    let sign = \"\";\n    flags = flags || \"\";\n    format = format || \"\";\n    if (isNumeric(rep)) {\n        if (format.toLowerCase() !== \"x\") {\n            if (isLessThan(rep, 0)) {\n                rep = multiply(rep, -1);\n                sign = \"-\";\n            }\n            else {\n                if (flags.indexOf(\" \") >= 0) {\n                    sign = \" \";\n                }\n                else if (flags.indexOf(\"+\") >= 0) {\n                    sign = \"+\";\n                }\n            }\n        }\n        precision = precision == null ? null : parseInt(precision, 10);\n        switch (format) {\n            case \"f\":\n            case \"F\":\n                precision = precision != null ? precision : 6;\n                rep = toFixed(rep, precision);\n                break;\n            case \"g\":\n            case \"G\":\n                rep = precision != null ? toPrecision(rep, precision) : toPrecision(rep);\n                break;\n            case \"e\":\n            case \"E\":\n                rep = precision != null ? toExponential(rep, precision) : toExponential(rep);\n                break;\n            case \"x\":\n                rep = toHex(rep);\n                break;\n            case \"X\":\n                rep = toHex(rep).toUpperCase();\n                break;\n            default: // AOid\n                rep = String(rep);\n                break;\n        }\n    }\n    else if (rep instanceof Date) {\n        rep = dateToString(rep);\n    }\n    else {\n        rep = toString(rep);\n    }\n    padLength = typeof padLength === \"number\" ? padLength : parseInt(padLength, 10);\n    if (!isNaN(padLength)) {\n        const zeroFlag = flags.indexOf(\"0\") >= 0; // Use '0' for left padding\n        const minusFlag = flags.indexOf(\"-\") >= 0; // Right padding\n        const ch = minusFlag || !zeroFlag ? \" \" : \"0\";\n        if (ch === \"0\") {\n            rep = padLeft(rep, padLength - sign.length, ch, minusFlag);\n            rep = sign + rep;\n        }\n        else {\n            rep = padLeft(sign + rep, padLength, ch, minusFlag);\n        }\n    }\n    else {\n        rep = sign + rep;\n    }\n    return rep;\n}\nfunction createPrinter(cont, _strParts, _matches, _result = \"\", padArg = -1) {\n    return (...args) => {\n        // Make copies of the values passed by reference because the function can be used multiple times\n        let result = _result;\n        const strParts = _strParts.slice();\n        const matches = _matches.slice();\n        for (const arg of args) {\n            const [, , flags, _padLength, precision, format] = matches[0];\n            let padLength = _padLength;\n            if (padArg >= 0) {\n                padLength = padArg;\n                padArg = -1;\n            }\n            else if (padLength === \"*\") {\n                if (arg < 0) {\n                    throw new Error(\"Non-negative number required\");\n                }\n                padArg = arg;\n                continue;\n            }\n            result += strParts[0];\n            result += formatReplacement(arg, flags, padLength, precision, format);\n            strParts.splice(0, 1);\n            matches.splice(0, 1);\n        }\n        if (matches.length === 0) {\n            result += strParts[0];\n            return cont(result);\n        }\n        else {\n            return createPrinter(cont, strParts, matches, result, padArg);\n        }\n    };\n}\nexport function fsFormat(str) {\n    return (cont) => {\n        fsFormatRegExp.lastIndex = 0;\n        const strParts = [];\n        const matches = [];\n        let strIdx = 0;\n        let match = fsFormatRegExp.exec(str);\n        while (match) {\n            // The first group corresponds to the no-escape char (^|[^%]), the actual pattern starts in the next char\n            // Note: we don't use negative lookbehind because some browsers don't support it yet\n            const matchIndex = match.index + (match[1] || \"\").length;\n            strParts.push(str.substring(strIdx, matchIndex).replace(/%%/g, \"%\"));\n            matches.push(match);\n            strIdx = fsFormatRegExp.lastIndex;\n            // Likewise we need to move fsFormatRegExp.lastIndex one char behind to make sure we match the no-escape char next time\n            fsFormatRegExp.lastIndex -= 1;\n            match = fsFormatRegExp.exec(str);\n        }\n        if (strParts.length === 0) {\n            return cont(str.replace(/%%/g, \"%\"));\n        }\n        else {\n            strParts.push(str.substring(strIdx).replace(/%%/g, \"%\"));\n            return createPrinter(cont, strParts, matches);\n        }\n    };\n}\nexport function format(str, ...args) {\n    if (typeof str === \"object\" && args.length > 0) {\n        // Called with culture info\n        str = args[0];\n        args.shift();\n    }\n    return str.replace(formatRegExp, (_, idx, padLength, format, precision, pattern) => {\n        let rep = args[idx];\n        if (isNumeric(rep)) {\n            precision = precision == null ? null : parseInt(precision, 10);\n            switch (format) {\n                case \"f\":\n                case \"F\":\n                    precision = precision != null ? precision : 2;\n                    rep = toFixed(rep, precision);\n                    break;\n                case \"g\":\n                case \"G\":\n                    rep = precision != null ? toPrecision(rep, precision) : toPrecision(rep);\n                    break;\n                case \"e\":\n                case \"E\":\n                    rep = precision != null ? toExponential(rep, precision) : toExponential(rep);\n                    break;\n                case \"p\":\n                case \"P\":\n                    precision = precision != null ? precision : 2;\n                    rep = toFixed(multiply(rep, 100), precision) + \" %\";\n                    break;\n                case \"d\":\n                case \"D\":\n                    rep = precision != null ? padLeft(String(rep), precision, \"0\") : String(rep);\n                    break;\n                case \"x\":\n                case \"X\":\n                    rep = precision != null ? padLeft(toHex(rep), precision, \"0\") : toHex(rep);\n                    if (format === \"X\") {\n                        rep = rep.toUpperCase();\n                    }\n                    break;\n                default:\n                    if (pattern) {\n                        let sign = \"\";\n                        rep = pattern.replace(/(0+)(\\.0+)?/, (_, intPart, decimalPart) => {\n                            if (isLessThan(rep, 0)) {\n                                rep = multiply(rep, -1);\n                                sign = \"-\";\n                            }\n                            rep = toFixed(rep, decimalPart != null ? decimalPart.length - 1 : 0);\n                            return padLeft(rep, (intPart || \"\").length - sign.length + (decimalPart != null ? decimalPart.length : 0), \"0\");\n                        });\n                        rep = sign + rep;\n                    }\n            }\n        }\n        else if (rep instanceof Date) {\n            rep = dateToString(rep, pattern || format);\n        }\n        else {\n            rep = toString(rep);\n        }\n        padLength = parseInt((padLength || \" \").substring(1), 10);\n        if (!isNaN(padLength)) {\n            rep = padLeft(String(rep), Math.abs(padLength), \" \", padLength < 0);\n        }\n        return rep;\n    });\n}\nexport function endsWith(str, search) {\n    const idx = str.lastIndexOf(search);\n    return idx >= 0 && idx === str.length - search.length;\n}\nexport function initialize(n, f) {\n    if (n < 0) {\n        throw new Error(\"String length must be non-negative\");\n    }\n    const xs = new Array(n);\n    for (let i = 0; i < n; i++) {\n        xs[i] = f(i);\n    }\n    return xs.join(\"\");\n}\nexport function insert(str, startIndex, value) {\n    if (startIndex < 0 || startIndex > str.length) {\n        throw new Error(\"startIndex is negative or greater than the length of this instance.\");\n    }\n    return str.substring(0, startIndex) + value + str.substring(startIndex);\n}\nexport function isNullOrEmpty(str) {\n    return typeof str !== \"string\" || str.length === 0;\n}\nexport function isNullOrWhiteSpace(str) {\n    return typeof str !== \"string\" || /^\\s*$/.test(str);\n}\nexport function concat(...xs) {\n    return xs.map((x) => String(x)).join(\"\");\n}\nexport function join(delimiter, xs) {\n    if (Array.isArray(xs)) {\n        return xs.join(delimiter);\n    }\n    else {\n        return Array.from(xs).join(delimiter);\n    }\n}\nexport function joinWithIndices(delimiter, xs, startIndex, count) {\n    const endIndexPlusOne = startIndex + count;\n    if (endIndexPlusOne > xs.length) {\n        throw new Error(\"Index and count must refer to a location within the buffer.\");\n    }\n    return xs.slice(startIndex, endIndexPlusOne).join(delimiter);\n}\nfunction notSupported(name) {\n    throw new Error(\"The environment doesn't support '\" + name + \"', please use a polyfill.\");\n}\nexport function toBase64String(inArray) {\n    let str = \"\";\n    for (let i = 0; i < inArray.length; i++) {\n        str += String.fromCharCode(inArray[i]);\n    }\n    return typeof btoa === \"function\" ? btoa(str) : notSupported(\"btoa\");\n}\nexport function fromBase64String(b64Encoded) {\n    const binary = typeof atob === \"function\" ? atob(b64Encoded) : notSupported(\"atob\");\n    const bytes = new Uint8Array(binary.length);\n    for (let i = 0; i < binary.length; i++) {\n        bytes[i] = binary.charCodeAt(i);\n    }\n    return bytes;\n}\nexport function padLeft(str, len, ch, isRight) {\n    ch = ch || \" \";\n    len = len - str.length;\n    for (let i = 0; i < len; i++) {\n        str = isRight ? str + ch : ch + str;\n    }\n    return str;\n}\nexport function padRight(str, len, ch) {\n    return padLeft(str, len, ch, true);\n}\nexport function remove(str, startIndex, count) {\n    if (startIndex >= str.length) {\n        throw new Error(\"startIndex must be less than length of string\");\n    }\n    if (typeof count === \"number\" && (startIndex + count) > str.length) {\n        throw new Error(\"Index and count must refer to a location within the string.\");\n    }\n    return str.slice(0, startIndex) + (typeof count === \"number\" ? str.substr(startIndex + count) : \"\");\n}\nexport function replace(str, search, replace) {\n    return str.replace(new RegExp(escape(search), \"g\"), replace);\n}\nexport function replicate(n, x) {\n    return initialize(n, () => x);\n}\nexport function getCharAtIndex(input, index) {\n    if (index < 0 || index >= input.length) {\n        throw new Error(\"Index was outside the bounds of the array.\");\n    }\n    return input[index];\n}\nexport function split(str, splitters, count, removeEmpty) {\n    count = typeof count === \"number\" ? count : undefined;\n    removeEmpty = typeof removeEmpty === \"number\" ? removeEmpty : undefined;\n    if (count && count < 0) {\n        throw new Error(\"Count cannot be less than zero\");\n    }\n    if (count === 0) {\n        return [];\n    }\n    if (!Array.isArray(splitters)) {\n        if (removeEmpty === 0) {\n            return str.split(splitters, count);\n        }\n        const len = arguments.length;\n        splitters = Array(len - 1);\n        for (let key = 1; key < len; key++) {\n            splitters[key - 1] = arguments[key];\n        }\n    }\n    splitters = splitters.map((x) => escape(x));\n    splitters = splitters.length > 0 ? splitters : [\" \"];\n    let i = 0;\n    const splits = [];\n    const reg = new RegExp(splitters.join(\"|\"), \"g\");\n    while (count == null || count > 1) {\n        const m = reg.exec(str);\n        if (m === null) {\n            break;\n        }\n        if (!removeEmpty || (m.index - i) > 0) {\n            count = count != null ? count - 1 : count;\n            splits.push(str.substring(i, m.index));\n        }\n        i = reg.lastIndex;\n    }\n    if (!removeEmpty || (str.length - i) > 0) {\n        splits.push(str.substring(i));\n    }\n    return splits;\n}\nexport function trim(str, ...chars) {\n    if (chars.length === 0) {\n        return str.trim();\n    }\n    const pattern = \"[\" + escape(chars.join(\"\")) + \"]+\";\n    return str.replace(new RegExp(\"^\" + pattern), \"\").replace(new RegExp(pattern + \"$\"), \"\");\n}\nexport function trimStart(str, ...chars) {\n    return chars.length === 0\n        ? str.trimStart()\n        : str.replace(new RegExp(\"^[\" + escape(chars.join(\"\")) + \"]+\"), \"\");\n}\nexport function trimEnd(str, ...chars) {\n    return chars.length === 0\n        ? str.trimEnd()\n        : str.replace(new RegExp(\"[\" + escape(chars.join(\"\")) + \"]+$\"), \"\");\n}\nexport function filter(pred, x) {\n    return x.split(\"\").filter((c) => pred(c)).join(\"\");\n}\nexport function substring(str, startIndex, length) {\n    if ((startIndex + (length || 0) > str.length)) {\n        throw new Error(\"Invalid startIndex and/or length\");\n    }\n    return length != null ? str.substr(startIndex, length) : str.substr(startIndex);\n}\n","import { join } from \"./String.js\";\r\nimport { uncurry, isArrayLike, getEnumerator, toIterator, compare, structuralHash, equals } from \"./Util.js\";\r\nimport { Record } from \"./Types.js\";\r\nimport { class_type, record_type, option_type } from \"./Reflection.js\";\r\nimport { defaultArg, value as value_1, some } from \"./Option.js\";\r\nimport { transpose as transpose_1, splitInto as splitInto_1, windowed as windowed_1, pairwise as pairwise_1, chunkBySize as chunkBySize_1, map as map_1, permute as permute_1, tryFindIndexBack as tryFindIndexBack_1, tryFindBack as tryFindBack_1, scanBack as scanBack_1, foldBack2 as foldBack2_1, foldBack as foldBack_1, fill } from \"./Array.js\";\r\n\r\nexport const SR_indexOutOfBounds = \"The index was outside the range of elements in the list.\";\r\n\r\nexport const SR_inputListWasEmpty = \"List was empty\";\r\n\r\nexport const SR_inputMustBeNonNegative = \"The input must be non-negative.\";\r\n\r\nexport const SR_inputSequenceEmpty = \"The input sequence was empty.\";\r\n\r\nexport const SR_inputSequenceTooLong = \"The input sequence contains more than one element.\";\r\n\r\nexport const SR_keyNotFoundAlt = \"An index satisfying the predicate was not found in the collection.\";\r\n\r\nexport const SR_listsHadDifferentLengths = \"The lists had different lengths.\";\r\n\r\nexport const SR_notEnoughElements = \"The input sequence has an insufficient number of elements.\";\r\n\r\nexport class FSharpList extends Record {\r\n    constructor(head, tail) {\r\n        super();\r\n        this.head = head;\r\n        this.tail = tail;\r\n    }\r\n    toString() {\r\n        const xs = this;\r\n        return (\"[\" + join(\"; \", xs)) + \"]\";\r\n    }\r\n    Equals(other) {\r\n        const xs = this;\r\n        if (xs === other) {\r\n            return true;\r\n        }\r\n        else {\r\n            const loop = (xs_1_mut, ys_1_mut) => {\r\n                loop:\r\n                while (true) {\r\n                    const xs_1 = xs_1_mut, ys_1 = ys_1_mut;\r\n                    const matchValue = [xs_1.tail, ys_1.tail];\r\n                    if (matchValue[0] != null) {\r\n                        if (matchValue[1] != null) {\r\n                            const xt = matchValue[0];\r\n                            const yt = matchValue[1];\r\n                            if (equals(xs_1.head, ys_1.head)) {\r\n                                xs_1_mut = xt;\r\n                                ys_1_mut = yt;\r\n                                continue loop;\r\n                            }\r\n                            else {\r\n                                return false;\r\n                            }\r\n                        }\r\n                        else {\r\n                            return false;\r\n                        }\r\n                    }\r\n                    else if (matchValue[1] != null) {\r\n                        return false;\r\n                    }\r\n                    else {\r\n                        return true;\r\n                    }\r\n                    break;\r\n                }\r\n            };\r\n            return loop(xs, other);\r\n        }\r\n    }\r\n    GetHashCode() {\r\n        const xs = this;\r\n        const loop = (i_mut, h_mut, xs_1_mut) => {\r\n            loop:\r\n            while (true) {\r\n                const i = i_mut, h = h_mut, xs_1 = xs_1_mut;\r\n                const matchValue = xs_1.tail;\r\n                if (matchValue != null) {\r\n                    const t = matchValue;\r\n                    if (i > 18) {\r\n                        return h | 0;\r\n                    }\r\n                    else {\r\n                        i_mut = (i + 1);\r\n                        h_mut = (((h << 1) + structuralHash(xs_1.head)) + (631 * i));\r\n                        xs_1_mut = t;\r\n                        continue loop;\r\n                    }\r\n                }\r\n                else {\r\n                    return h | 0;\r\n                }\r\n                break;\r\n            }\r\n        };\r\n        return loop(0, 0, xs) | 0;\r\n    }\r\n    toJSON(_key) {\r\n        const this$ = this;\r\n        return Array.from(this$);\r\n    }\r\n    CompareTo(other) {\r\n        const xs = this;\r\n        const loop = (xs_1_mut, ys_1_mut) => {\r\n            loop:\r\n            while (true) {\r\n                const xs_1 = xs_1_mut, ys_1 = ys_1_mut;\r\n                const matchValue = [xs_1.tail, ys_1.tail];\r\n                if (matchValue[0] != null) {\r\n                    if (matchValue[1] != null) {\r\n                        const xt = matchValue[0];\r\n                        const yt = matchValue[1];\r\n                        const c = compare(xs_1.head, ys_1.head) | 0;\r\n                        if (c === 0) {\r\n                            xs_1_mut = xt;\r\n                            ys_1_mut = yt;\r\n                            continue loop;\r\n                        }\r\n                        else {\r\n                            return c | 0;\r\n                        }\r\n                    }\r\n                    else {\r\n                        return 1;\r\n                    }\r\n                }\r\n                else if (matchValue[1] != null) {\r\n                    return -1;\r\n                }\r\n                else {\r\n                    return 0;\r\n                }\r\n                break;\r\n            }\r\n        };\r\n        return loop(xs, other) | 0;\r\n    }\r\n    GetEnumerator() {\r\n        const xs = this;\r\n        return ListEnumerator$1_$ctor_3002E699(xs);\r\n    }\r\n    [Symbol.iterator]() {\r\n        return toIterator(this.GetEnumerator());\r\n    }\r\n    [\"System.Collections.IEnumerable.GetEnumerator\"]() {\r\n        const xs = this;\r\n        return getEnumerator(xs);\r\n    }\r\n}\r\n\r\nexport function FSharpList$reflection(gen0) {\r\n    return record_type(\"ListModule.FSharpList\", [gen0], FSharpList, () => [[\"head\", gen0], [\"tail\", option_type(FSharpList$reflection(gen0))]]);\r\n}\r\n\r\nexport class ListEnumerator$1 {\r\n    constructor(xs) {\r\n        this.xs = xs;\r\n        this.it = this.xs;\r\n        this.current = null;\r\n    }\r\n    [\"System.Collections.Generic.IEnumerator`1.get_Current\"]() {\r\n        const __ = this;\r\n        return __.current;\r\n    }\r\n    [\"System.Collections.IEnumerator.get_Current\"]() {\r\n        const __ = this;\r\n        return __.current;\r\n    }\r\n    [\"System.Collections.IEnumerator.MoveNext\"]() {\r\n        const __ = this;\r\n        const matchValue = __.it.tail;\r\n        if (matchValue != null) {\r\n            const t = matchValue;\r\n            __.current = __.it.head;\r\n            __.it = t;\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n    [\"System.Collections.IEnumerator.Reset\"]() {\r\n        const __ = this;\r\n        __.it = __.xs;\r\n        __.current = null;\r\n    }\r\n    Dispose() {\r\n    }\r\n}\r\n\r\nexport function ListEnumerator$1$reflection(gen0) {\r\n    return class_type(\"ListModule.ListEnumerator`1\", [gen0], ListEnumerator$1);\r\n}\r\n\r\nexport function ListEnumerator$1_$ctor_3002E699(xs) {\r\n    return new ListEnumerator$1(xs);\r\n}\r\n\r\nexport function FSharpList_get_Empty() {\r\n    return new FSharpList(null, void 0);\r\n}\r\n\r\nexport function FSharpList_Cons_305B8EAC(x, xs) {\r\n    return new FSharpList(x, xs);\r\n}\r\n\r\nexport function FSharpList__get_IsEmpty(xs) {\r\n    return xs.tail == null;\r\n}\r\n\r\nexport function FSharpList__get_Length(xs) {\r\n    const loop = (i_mut, xs_1_mut) => {\r\n        loop:\r\n        while (true) {\r\n            const i = i_mut, xs_1 = xs_1_mut;\r\n            const matchValue = xs_1.tail;\r\n            if (matchValue != null) {\r\n                i_mut = (i + 1);\r\n                xs_1_mut = matchValue;\r\n                continue loop;\r\n            }\r\n            else {\r\n                return i | 0;\r\n            }\r\n            break;\r\n        }\r\n    };\r\n    return loop(0, xs) | 0;\r\n}\r\n\r\nexport function FSharpList__get_Head(xs) {\r\n    const matchValue = xs.tail;\r\n    if (matchValue != null) {\r\n        return xs.head;\r\n    }\r\n    else {\r\n        throw (new Error((SR_inputListWasEmpty + \"\\\\nParameter name: \") + \"list\"));\r\n    }\r\n}\r\n\r\nexport function FSharpList__get_Tail(xs) {\r\n    const matchValue = xs.tail;\r\n    if (matchValue != null) {\r\n        return matchValue;\r\n    }\r\n    else {\r\n        throw (new Error((SR_inputListWasEmpty + \"\\\\nParameter name: \") + \"list\"));\r\n    }\r\n}\r\n\r\nexport function FSharpList__get_Item_Z524259A4(xs, index) {\r\n    const loop = (i_mut, xs_1_mut) => {\r\n        loop:\r\n        while (true) {\r\n            const i = i_mut, xs_1 = xs_1_mut;\r\n            const matchValue = xs_1.tail;\r\n            if (matchValue != null) {\r\n                if (i === index) {\r\n                    return xs_1.head;\r\n                }\r\n                else {\r\n                    i_mut = (i + 1);\r\n                    xs_1_mut = matchValue;\r\n                    continue loop;\r\n                }\r\n            }\r\n            else {\r\n                throw (new Error((SR_indexOutOfBounds + \"\\\\nParameter name: \") + \"index\"));\r\n            }\r\n            break;\r\n        }\r\n    };\r\n    return loop(0, xs);\r\n}\r\n\r\nexport function empty() {\r\n    return FSharpList_get_Empty();\r\n}\r\n\r\nexport function cons(x, xs) {\r\n    return FSharpList_Cons_305B8EAC(x, xs);\r\n}\r\n\r\nexport function singleton(x) {\r\n    return FSharpList_Cons_305B8EAC(x, FSharpList_get_Empty());\r\n}\r\n\r\nexport function isEmpty(xs) {\r\n    return FSharpList__get_IsEmpty(xs);\r\n}\r\n\r\nexport function length(xs) {\r\n    return FSharpList__get_Length(xs);\r\n}\r\n\r\nexport function head(xs) {\r\n    return FSharpList__get_Head(xs);\r\n}\r\n\r\nexport function tryHead(xs) {\r\n    if (FSharpList__get_IsEmpty(xs)) {\r\n        return void 0;\r\n    }\r\n    else {\r\n        return some(FSharpList__get_Head(xs));\r\n    }\r\n}\r\n\r\nexport function tail(xs) {\r\n    return FSharpList__get_Tail(xs);\r\n}\r\n\r\nexport function tryLast(xs_mut) {\r\n    tryLast:\r\n    while (true) {\r\n        const xs = xs_mut;\r\n        if (FSharpList__get_IsEmpty(xs)) {\r\n            return void 0;\r\n        }\r\n        else {\r\n            const t = FSharpList__get_Tail(xs);\r\n            if (FSharpList__get_IsEmpty(t)) {\r\n                return some(FSharpList__get_Head(xs));\r\n            }\r\n            else {\r\n                xs_mut = t;\r\n                continue tryLast;\r\n            }\r\n        }\r\n        break;\r\n    }\r\n}\r\n\r\nexport function last(xs) {\r\n    const matchValue = tryLast(xs);\r\n    if (matchValue == null) {\r\n        throw (new Error(SR_inputListWasEmpty));\r\n    }\r\n    else {\r\n        return value_1(matchValue);\r\n    }\r\n}\r\n\r\nexport function compareWith(comparer, xs, ys) {\r\n    const loop = (xs_1_mut, ys_1_mut) => {\r\n        loop:\r\n        while (true) {\r\n            const xs_1 = xs_1_mut, ys_1 = ys_1_mut;\r\n            const matchValue = [FSharpList__get_IsEmpty(xs_1), FSharpList__get_IsEmpty(ys_1)];\r\n            if (matchValue[0]) {\r\n                if (matchValue[1]) {\r\n                    return 0;\r\n                }\r\n                else {\r\n                    return -1;\r\n                }\r\n            }\r\n            else if (matchValue[1]) {\r\n                return 1;\r\n            }\r\n            else {\r\n                const c = comparer(FSharpList__get_Head(xs_1), FSharpList__get_Head(ys_1)) | 0;\r\n                if (c === 0) {\r\n                    xs_1_mut = FSharpList__get_Tail(xs_1);\r\n                    ys_1_mut = FSharpList__get_Tail(ys_1);\r\n                    continue loop;\r\n                }\r\n                else {\r\n                    return c | 0;\r\n                }\r\n            }\r\n            break;\r\n        }\r\n    };\r\n    return loop(xs, ys) | 0;\r\n}\r\n\r\nexport function toArray(xs) {\r\n    const len = FSharpList__get_Length(xs) | 0;\r\n    const res = fill(new Array(len), 0, len, null);\r\n    const loop = (i_mut, xs_1_mut) => {\r\n        loop:\r\n        while (true) {\r\n            const i = i_mut, xs_1 = xs_1_mut;\r\n            if (!FSharpList__get_IsEmpty(xs_1)) {\r\n                res[i] = FSharpList__get_Head(xs_1);\r\n                i_mut = (i + 1);\r\n                xs_1_mut = FSharpList__get_Tail(xs_1);\r\n                continue loop;\r\n            }\r\n            break;\r\n        }\r\n    };\r\n    loop(0, xs);\r\n    return res;\r\n}\r\n\r\nexport function fold(folder, state, xs) {\r\n    let acc = state;\r\n    let xs_1 = xs;\r\n    while (!FSharpList__get_IsEmpty(xs_1)) {\r\n        acc = folder(acc, FSharpList__get_Head(xs_1));\r\n        xs_1 = FSharpList__get_Tail(xs_1);\r\n    }\r\n    return acc;\r\n}\r\n\r\nexport function reverse(xs) {\r\n    return fold((acc, x) => FSharpList_Cons_305B8EAC(x, acc), FSharpList_get_Empty(), xs);\r\n}\r\n\r\nexport function foldBack(folder, xs, state) {\r\n    return foldBack_1(folder, toArray(xs), state);\r\n}\r\n\r\nexport function foldIndexed(folder, state, xs) {\r\n    const loop = (i_mut, acc_mut, xs_1_mut) => {\r\n        loop:\r\n        while (true) {\r\n            const i = i_mut, acc = acc_mut, xs_1 = xs_1_mut;\r\n            if (FSharpList__get_IsEmpty(xs_1)) {\r\n                return acc;\r\n            }\r\n            else {\r\n                i_mut = (i + 1);\r\n                acc_mut = folder(i, acc, FSharpList__get_Head(xs_1));\r\n                xs_1_mut = FSharpList__get_Tail(xs_1);\r\n                continue loop;\r\n            }\r\n            break;\r\n        }\r\n    };\r\n    return loop(0, state, xs);\r\n}\r\n\r\nexport function fold2(folder, state, xs, ys) {\r\n    let acc = state;\r\n    let xs_1 = xs;\r\n    let ys_1 = ys;\r\n    while ((!FSharpList__get_IsEmpty(xs_1)) ? (!FSharpList__get_IsEmpty(ys_1)) : false) {\r\n        acc = folder(acc, FSharpList__get_Head(xs_1), FSharpList__get_Head(ys_1));\r\n        xs_1 = FSharpList__get_Tail(xs_1);\r\n        ys_1 = FSharpList__get_Tail(ys_1);\r\n    }\r\n    return acc;\r\n}\r\n\r\nexport function foldBack2(folder, xs, ys, state) {\r\n    return foldBack2_1(folder, toArray(xs), toArray(ys), state);\r\n}\r\n\r\nexport function unfold(gen, state) {\r\n    const loop = (acc_mut, node_mut) => {\r\n        let t;\r\n        loop:\r\n        while (true) {\r\n            const acc = acc_mut, node = node_mut;\r\n            const matchValue = gen(acc);\r\n            if (matchValue != null) {\r\n                acc_mut = matchValue[1];\r\n                node_mut = ((t = (new FSharpList(matchValue[0], void 0)), (node.tail = t, t)));\r\n                continue loop;\r\n            }\r\n            else {\r\n                return node;\r\n            }\r\n            break;\r\n        }\r\n    };\r\n    const root = FSharpList_get_Empty();\r\n    const node_1 = loop(state, root);\r\n    const t_2 = FSharpList_get_Empty();\r\n    node_1.tail = t_2;\r\n    return FSharpList__get_Tail(root);\r\n}\r\n\r\nexport function iterate(action, xs) {\r\n    fold((unitVar0, x) => {\r\n        action(x);\r\n    }, void 0, xs);\r\n}\r\n\r\nexport function iterate2(action, xs, ys) {\r\n    fold2((unitVar0, x, y) => {\r\n        action(x, y);\r\n    }, void 0, xs, ys);\r\n}\r\n\r\nexport function iterateIndexed(action, xs) {\r\n    void fold((i, x) => {\r\n        action(i, x);\r\n        return (i + 1) | 0;\r\n    }, 0, xs);\r\n}\r\n\r\nexport function iterateIndexed2(action, xs, ys) {\r\n    void fold2((i, x, y) => {\r\n        action(i, x, y);\r\n        return (i + 1) | 0;\r\n    }, 0, xs, ys);\r\n}\r\n\r\nexport function toSeq(xs) {\r\n    return xs;\r\n}\r\n\r\nexport function ofArrayWithTail(xs, tail_1) {\r\n    let res = tail_1;\r\n    for (let i = xs.length - 1; i >= 0; i--) {\r\n        res = FSharpList_Cons_305B8EAC(xs[i], res);\r\n    }\r\n    return res;\r\n}\r\n\r\nexport function ofArray(xs) {\r\n    return ofArrayWithTail(xs, FSharpList_get_Empty());\r\n}\r\n\r\nexport function ofSeq(xs) {\r\n    let xs_3, t;\r\n    if (isArrayLike(xs)) {\r\n        return ofArray(xs);\r\n    }\r\n    else if (xs instanceof FSharpList) {\r\n        return xs;\r\n    }\r\n    else {\r\n        const root = FSharpList_get_Empty();\r\n        let node = root;\r\n        const enumerator = getEnumerator(xs);\r\n        try {\r\n            while (enumerator[\"System.Collections.IEnumerator.MoveNext\"]()) {\r\n                const x = enumerator[\"System.Collections.Generic.IEnumerator`1.get_Current\"]();\r\n                node = ((xs_3 = node, (t = (new FSharpList(x, void 0)), (xs_3.tail = t, t))));\r\n            }\r\n        }\r\n        finally {\r\n            enumerator.Dispose();\r\n        }\r\n        const xs_5 = node;\r\n        const t_2 = FSharpList_get_Empty();\r\n        xs_5.tail = t_2;\r\n        return FSharpList__get_Tail(root);\r\n    }\r\n}\r\n\r\nexport function concat(lists) {\r\n    const root = FSharpList_get_Empty();\r\n    let node = root;\r\n    const action = (xs) => {\r\n        node = fold((acc, x) => {\r\n            const t = new FSharpList(x, void 0);\r\n            acc.tail = t;\r\n            return t;\r\n        }, node, xs);\r\n    };\r\n    if (isArrayLike(lists)) {\r\n        lists.forEach(action);\r\n    }\r\n    else if (lists instanceof FSharpList) {\r\n        iterate(action, lists);\r\n    }\r\n    else {\r\n        const enumerator = getEnumerator(lists);\r\n        try {\r\n            while (enumerator[\"System.Collections.IEnumerator.MoveNext\"]()) {\r\n                action(enumerator[\"System.Collections.Generic.IEnumerator`1.get_Current\"]());\r\n            }\r\n        }\r\n        finally {\r\n            enumerator.Dispose();\r\n        }\r\n    }\r\n    const xs_6 = node;\r\n    const t_2 = FSharpList_get_Empty();\r\n    xs_6.tail = t_2;\r\n    return FSharpList__get_Tail(root);\r\n}\r\n\r\nexport function scan(folder, state, xs) {\r\n    let xs_4, t_2;\r\n    const root = FSharpList_get_Empty();\r\n    let node;\r\n    const t = new FSharpList(state, void 0);\r\n    root.tail = t;\r\n    node = t;\r\n    let acc = state;\r\n    let xs_3 = xs;\r\n    while (!FSharpList__get_IsEmpty(xs_3)) {\r\n        acc = folder(acc, FSharpList__get_Head(xs_3));\r\n        node = ((xs_4 = node, (t_2 = (new FSharpList(acc, void 0)), (xs_4.tail = t_2, t_2))));\r\n        xs_3 = FSharpList__get_Tail(xs_3);\r\n    }\r\n    const xs_6 = node;\r\n    const t_4 = FSharpList_get_Empty();\r\n    xs_6.tail = t_4;\r\n    return FSharpList__get_Tail(root);\r\n}\r\n\r\nexport function scanBack(folder, xs, state) {\r\n    return ofArray(scanBack_1(folder, toArray(xs), state));\r\n}\r\n\r\nexport function append(xs, ys) {\r\n    return fold((acc, x) => FSharpList_Cons_305B8EAC(x, acc), ys, reverse(xs));\r\n}\r\n\r\nexport function collect(mapping, xs) {\r\n    let xs_1, t;\r\n    const root = FSharpList_get_Empty();\r\n    let node = root;\r\n    let ys = xs;\r\n    while (!FSharpList__get_IsEmpty(ys)) {\r\n        let zs = mapping(FSharpList__get_Head(ys));\r\n        while (!FSharpList__get_IsEmpty(zs)) {\r\n            node = ((xs_1 = node, (t = (new FSharpList(FSharpList__get_Head(zs), void 0)), (xs_1.tail = t, t))));\r\n            zs = FSharpList__get_Tail(zs);\r\n        }\r\n        ys = FSharpList__get_Tail(ys);\r\n    }\r\n    const xs_3 = node;\r\n    const t_2 = FSharpList_get_Empty();\r\n    xs_3.tail = t_2;\r\n    return FSharpList__get_Tail(root);\r\n}\r\n\r\nexport function mapIndexed(mapping, xs) {\r\n    const root = FSharpList_get_Empty();\r\n    const node = foldIndexed((i, acc, x) => {\r\n        const t = new FSharpList(mapping(i, x), void 0);\r\n        acc.tail = t;\r\n        return t;\r\n    }, root, xs);\r\n    const t_2 = FSharpList_get_Empty();\r\n    node.tail = t_2;\r\n    return FSharpList__get_Tail(root);\r\n}\r\n\r\nexport function map(mapping, xs) {\r\n    const root = FSharpList_get_Empty();\r\n    const node = fold((acc, x) => {\r\n        const t = new FSharpList(mapping(x), void 0);\r\n        acc.tail = t;\r\n        return t;\r\n    }, root, xs);\r\n    const t_2 = FSharpList_get_Empty();\r\n    node.tail = t_2;\r\n    return FSharpList__get_Tail(root);\r\n}\r\n\r\nexport function indexed(xs) {\r\n    return mapIndexed((i, x) => [i, x], xs);\r\n}\r\n\r\nexport function map2(mapping, xs, ys) {\r\n    const root = FSharpList_get_Empty();\r\n    const node = fold2((acc, x, y) => {\r\n        const t = new FSharpList(mapping(x, y), void 0);\r\n        acc.tail = t;\r\n        return t;\r\n    }, root, xs, ys);\r\n    const t_2 = FSharpList_get_Empty();\r\n    node.tail = t_2;\r\n    return FSharpList__get_Tail(root);\r\n}\r\n\r\nexport function mapIndexed2(mapping, xs, ys) {\r\n    const loop = (i_mut, acc_mut, xs_1_mut, ys_1_mut) => {\r\n        let t;\r\n        loop:\r\n        while (true) {\r\n            const i = i_mut, acc = acc_mut, xs_1 = xs_1_mut, ys_1 = ys_1_mut;\r\n            if (FSharpList__get_IsEmpty(xs_1) ? true : FSharpList__get_IsEmpty(ys_1)) {\r\n                return acc;\r\n            }\r\n            else {\r\n                i_mut = (i + 1);\r\n                acc_mut = ((t = (new FSharpList(mapping(i, FSharpList__get_Head(xs_1), FSharpList__get_Head(ys_1)), void 0)), (acc.tail = t, t)));\r\n                xs_1_mut = FSharpList__get_Tail(xs_1);\r\n                ys_1_mut = FSharpList__get_Tail(ys_1);\r\n                continue loop;\r\n            }\r\n            break;\r\n        }\r\n    };\r\n    const root = FSharpList_get_Empty();\r\n    const node_1 = loop(0, root, xs, ys);\r\n    const t_2 = FSharpList_get_Empty();\r\n    node_1.tail = t_2;\r\n    return FSharpList__get_Tail(root);\r\n}\r\n\r\nexport function map3(mapping, xs, ys, zs) {\r\n    const loop = (acc_mut, xs_1_mut, ys_1_mut, zs_1_mut) => {\r\n        let t;\r\n        loop:\r\n        while (true) {\r\n            const acc = acc_mut, xs_1 = xs_1_mut, ys_1 = ys_1_mut, zs_1 = zs_1_mut;\r\n            if ((FSharpList__get_IsEmpty(xs_1) ? true : FSharpList__get_IsEmpty(ys_1)) ? true : FSharpList__get_IsEmpty(zs_1)) {\r\n                return acc;\r\n            }\r\n            else {\r\n                acc_mut = ((t = (new FSharpList(mapping(FSharpList__get_Head(xs_1), FSharpList__get_Head(ys_1), FSharpList__get_Head(zs_1)), void 0)), (acc.tail = t, t)));\r\n                xs_1_mut = FSharpList__get_Tail(xs_1);\r\n                ys_1_mut = FSharpList__get_Tail(ys_1);\r\n                zs_1_mut = FSharpList__get_Tail(zs_1);\r\n                continue loop;\r\n            }\r\n            break;\r\n        }\r\n    };\r\n    const root = FSharpList_get_Empty();\r\n    const node_1 = loop(root, xs, ys, zs);\r\n    const t_2 = FSharpList_get_Empty();\r\n    node_1.tail = t_2;\r\n    return FSharpList__get_Tail(root);\r\n}\r\n\r\nexport function mapFold(mapping, state, xs) {\r\n    const root = FSharpList_get_Empty();\r\n    const patternInput_1 = fold((tupledArg, x) => {\r\n        let t;\r\n        const patternInput = mapping(tupledArg[1], x);\r\n        return [(t = (new FSharpList(patternInput[0], void 0)), (tupledArg[0].tail = t, t)), patternInput[1]];\r\n    }, [root, state], xs);\r\n    const t_2 = FSharpList_get_Empty();\r\n    patternInput_1[0].tail = t_2;\r\n    return [FSharpList__get_Tail(root), patternInput_1[1]];\r\n}\r\n\r\nexport function mapFoldBack(mapping, xs, state) {\r\n    return mapFold((acc, x) => mapping(x, acc), state, reverse(xs));\r\n}\r\n\r\nexport function tryPick(f, xs) {\r\n    const loop = (xs_1_mut) => {\r\n        loop:\r\n        while (true) {\r\n            const xs_1 = xs_1_mut;\r\n            if (FSharpList__get_IsEmpty(xs_1)) {\r\n                return void 0;\r\n            }\r\n            else {\r\n                const matchValue = f(FSharpList__get_Head(xs_1));\r\n                if (matchValue == null) {\r\n                    xs_1_mut = FSharpList__get_Tail(xs_1);\r\n                    continue loop;\r\n                }\r\n                else {\r\n                    return matchValue;\r\n                }\r\n            }\r\n            break;\r\n        }\r\n    };\r\n    return loop(xs);\r\n}\r\n\r\nexport function pick(f, xs) {\r\n    const matchValue = tryPick(f, xs);\r\n    if (matchValue == null) {\r\n        throw (new Error(SR_keyNotFoundAlt));\r\n    }\r\n    else {\r\n        return value_1(matchValue);\r\n    }\r\n}\r\n\r\nexport function tryFind(f, xs) {\r\n    return tryPick((x) => (f(x) ? some(x) : (void 0)), xs);\r\n}\r\n\r\nexport function find(f, xs) {\r\n    const matchValue = tryFind(f, xs);\r\n    if (matchValue == null) {\r\n        throw (new Error(SR_keyNotFoundAlt));\r\n    }\r\n    else {\r\n        return value_1(matchValue);\r\n    }\r\n}\r\n\r\nexport function tryFindBack(f, xs) {\r\n    return tryFindBack_1(f, toArray(xs));\r\n}\r\n\r\nexport function findBack(f, xs) {\r\n    const matchValue = tryFindBack(f, xs);\r\n    if (matchValue == null) {\r\n        throw (new Error(SR_keyNotFoundAlt));\r\n    }\r\n    else {\r\n        return value_1(matchValue);\r\n    }\r\n}\r\n\r\nexport function tryFindIndex(f, xs) {\r\n    const loop = (i_mut, xs_1_mut) => {\r\n        loop:\r\n        while (true) {\r\n            const i = i_mut, xs_1 = xs_1_mut;\r\n            if (FSharpList__get_IsEmpty(xs_1)) {\r\n                return void 0;\r\n            }\r\n            else if (f(FSharpList__get_Head(xs_1))) {\r\n                return i;\r\n            }\r\n            else {\r\n                i_mut = (i + 1);\r\n                xs_1_mut = FSharpList__get_Tail(xs_1);\r\n                continue loop;\r\n            }\r\n            break;\r\n        }\r\n    };\r\n    return loop(0, xs);\r\n}\r\n\r\nexport function findIndex(f, xs) {\r\n    const matchValue = tryFindIndex(f, xs);\r\n    if (matchValue == null) {\r\n        throw (new Error(SR_keyNotFoundAlt));\r\n    }\r\n    else {\r\n        return matchValue | 0;\r\n    }\r\n}\r\n\r\nexport function tryFindIndexBack(f, xs) {\r\n    return tryFindIndexBack_1(f, toArray(xs));\r\n}\r\n\r\nexport function findIndexBack(f, xs) {\r\n    const matchValue = tryFindIndexBack(f, xs);\r\n    if (matchValue == null) {\r\n        throw (new Error(SR_keyNotFoundAlt));\r\n    }\r\n    else {\r\n        return matchValue | 0;\r\n    }\r\n}\r\n\r\nexport function tryItem(n, xs) {\r\n    const loop = (i_mut, xs_1_mut) => {\r\n        loop:\r\n        while (true) {\r\n            const i = i_mut, xs_1 = xs_1_mut;\r\n            if (FSharpList__get_IsEmpty(xs_1)) {\r\n                return void 0;\r\n            }\r\n            else if (i === n) {\r\n                return some(FSharpList__get_Head(xs_1));\r\n            }\r\n            else {\r\n                i_mut = (i + 1);\r\n                xs_1_mut = FSharpList__get_Tail(xs_1);\r\n                continue loop;\r\n            }\r\n            break;\r\n        }\r\n    };\r\n    return loop(0, xs);\r\n}\r\n\r\nexport function item(n, xs) {\r\n    return FSharpList__get_Item_Z524259A4(xs, n);\r\n}\r\n\r\nexport function filter(f, xs) {\r\n    const root = FSharpList_get_Empty();\r\n    const node = fold((acc, x) => {\r\n        if (f(x)) {\r\n            const t = new FSharpList(x, void 0);\r\n            acc.tail = t;\r\n            return t;\r\n        }\r\n        else {\r\n            return acc;\r\n        }\r\n    }, root, xs);\r\n    const t_2 = FSharpList_get_Empty();\r\n    node.tail = t_2;\r\n    return FSharpList__get_Tail(root);\r\n}\r\n\r\nexport function partition(f, xs) {\r\n    const patternInput = [FSharpList_get_Empty(), FSharpList_get_Empty()];\r\n    const root2 = patternInput[1];\r\n    const root1 = patternInput[0];\r\n    const patternInput_1 = fold(uncurry(2, (tupledArg) => {\r\n        const lacc = tupledArg[0];\r\n        const racc = tupledArg[1];\r\n        return (x) => {\r\n            let t, t_2;\r\n            return f(x) ? [(t = (new FSharpList(x, void 0)), (lacc.tail = t, t)), racc] : [lacc, (t_2 = (new FSharpList(x, void 0)), (racc.tail = t_2, t_2))];\r\n        };\r\n    }), [root1, root2], xs);\r\n    const t_4 = FSharpList_get_Empty();\r\n    patternInput_1[0].tail = t_4;\r\n    const t_5 = FSharpList_get_Empty();\r\n    patternInput_1[1].tail = t_5;\r\n    return [FSharpList__get_Tail(root1), FSharpList__get_Tail(root2)];\r\n}\r\n\r\nexport function choose(f, xs) {\r\n    const root = FSharpList_get_Empty();\r\n    const node = fold((acc, x) => {\r\n        const matchValue = f(x);\r\n        if (matchValue == null) {\r\n            return acc;\r\n        }\r\n        else {\r\n            const t = new FSharpList(value_1(matchValue), void 0);\r\n            acc.tail = t;\r\n            return t;\r\n        }\r\n    }, root, xs);\r\n    const t_2 = FSharpList_get_Empty();\r\n    node.tail = t_2;\r\n    return FSharpList__get_Tail(root);\r\n}\r\n\r\nexport function contains(value, xs, eq) {\r\n    return tryFindIndex((v) => eq.Equals(value, v), xs) != null;\r\n}\r\n\r\nexport function initialize(n, f) {\r\n    let xs, t;\r\n    const root = FSharpList_get_Empty();\r\n    let node = root;\r\n    for (let i = 0; i <= (n - 1); i++) {\r\n        node = ((xs = node, (t = (new FSharpList(f(i), void 0)), (xs.tail = t, t))));\r\n    }\r\n    const xs_2 = node;\r\n    const t_2 = FSharpList_get_Empty();\r\n    xs_2.tail = t_2;\r\n    return FSharpList__get_Tail(root);\r\n}\r\n\r\nexport function replicate(n, x) {\r\n    return initialize(n, (_arg1) => x);\r\n}\r\n\r\nexport function reduce(f, xs) {\r\n    if (FSharpList__get_IsEmpty(xs)) {\r\n        throw (new Error(SR_inputListWasEmpty));\r\n    }\r\n    else {\r\n        return fold(f, head(xs), tail(xs));\r\n    }\r\n}\r\n\r\nexport function reduceBack(f, xs) {\r\n    if (FSharpList__get_IsEmpty(xs)) {\r\n        throw (new Error(SR_inputListWasEmpty));\r\n    }\r\n    else {\r\n        return foldBack(f, tail(xs), head(xs));\r\n    }\r\n}\r\n\r\nexport function forAll(f, xs) {\r\n    return fold((acc, x) => (acc ? f(x) : false), true, xs);\r\n}\r\n\r\nexport function forAll2(f, xs, ys) {\r\n    return fold2((acc, x, y) => (acc ? f(x, y) : false), true, xs, ys);\r\n}\r\n\r\nexport function exists(f, xs) {\r\n    return tryFindIndex(f, xs) != null;\r\n}\r\n\r\nexport function exists2(f_mut, xs_mut, ys_mut) {\r\n    exists2:\r\n    while (true) {\r\n        const f = f_mut, xs = xs_mut, ys = ys_mut;\r\n        const matchValue = [FSharpList__get_IsEmpty(xs), FSharpList__get_IsEmpty(ys)];\r\n        let pattern_matching_result;\r\n        if (matchValue[0]) {\r\n            if (matchValue[1]) {\r\n                pattern_matching_result = 0;\r\n            }\r\n            else {\r\n                pattern_matching_result = 2;\r\n            }\r\n        }\r\n        else if (matchValue[1]) {\r\n            pattern_matching_result = 2;\r\n        }\r\n        else {\r\n            pattern_matching_result = 1;\r\n        }\r\n        switch (pattern_matching_result) {\r\n            case 0: {\r\n                return false;\r\n            }\r\n            case 1: {\r\n                if (f(FSharpList__get_Head(xs), FSharpList__get_Head(ys))) {\r\n                    return true;\r\n                }\r\n                else {\r\n                    f_mut = f;\r\n                    xs_mut = FSharpList__get_Tail(xs);\r\n                    ys_mut = FSharpList__get_Tail(ys);\r\n                    continue exists2;\r\n                }\r\n            }\r\n            case 2: {\r\n                throw (new Error((SR_listsHadDifferentLengths + \"\\\\nParameter name: \") + \"list2\"));\r\n            }\r\n        }\r\n        break;\r\n    }\r\n}\r\n\r\nexport function unzip(xs) {\r\n    return foldBack((tupledArg, tupledArg_1) => [FSharpList_Cons_305B8EAC(tupledArg[0], tupledArg_1[0]), FSharpList_Cons_305B8EAC(tupledArg[1], tupledArg_1[1])], xs, [FSharpList_get_Empty(), FSharpList_get_Empty()]);\r\n}\r\n\r\nexport function unzip3(xs) {\r\n    return foldBack((tupledArg, tupledArg_1) => [FSharpList_Cons_305B8EAC(tupledArg[0], tupledArg_1[0]), FSharpList_Cons_305B8EAC(tupledArg[1], tupledArg_1[1]), FSharpList_Cons_305B8EAC(tupledArg[2], tupledArg_1[2])], xs, [FSharpList_get_Empty(), FSharpList_get_Empty(), FSharpList_get_Empty()]);\r\n}\r\n\r\nexport function zip(xs, ys) {\r\n    return map2((x, y) => [x, y], xs, ys);\r\n}\r\n\r\nexport function zip3(xs, ys, zs) {\r\n    return map3((x, y, z) => [x, y, z], xs, ys, zs);\r\n}\r\n\r\nexport function sortWith(comparer, xs) {\r\n    const arr = toArray(xs);\r\n    arr.sort(comparer);\r\n    return ofArray(arr);\r\n}\r\n\r\nexport function sort(xs, comparer) {\r\n    return sortWith((x, y) => comparer.Compare(x, y), xs);\r\n}\r\n\r\nexport function sortBy(projection, xs, comparer) {\r\n    return sortWith((x, y) => comparer.Compare(projection(x), projection(y)), xs);\r\n}\r\n\r\nexport function sortDescending(xs, comparer) {\r\n    return sortWith((x, y) => (comparer.Compare(x, y) * -1), xs);\r\n}\r\n\r\nexport function sortByDescending(projection, xs, comparer) {\r\n    return sortWith((x, y) => (comparer.Compare(projection(x), projection(y)) * -1), xs);\r\n}\r\n\r\nexport function sum(xs, adder) {\r\n    return fold((acc, x) => adder.Add(acc, x), adder.GetZero(), xs);\r\n}\r\n\r\nexport function sumBy(f, xs, adder) {\r\n    return fold((acc, x) => adder.Add(acc, f(x)), adder.GetZero(), xs);\r\n}\r\n\r\nexport function maxBy(projection, xs, comparer) {\r\n    return reduce((x, y) => ((comparer.Compare(projection(y), projection(x)) > 0) ? y : x), xs);\r\n}\r\n\r\nexport function max(xs, comparer) {\r\n    return reduce((x, y) => ((comparer.Compare(y, x) > 0) ? y : x), xs);\r\n}\r\n\r\nexport function minBy(projection, xs, comparer) {\r\n    return reduce((x, y) => ((comparer.Compare(projection(y), projection(x)) > 0) ? x : y), xs);\r\n}\r\n\r\nexport function min(xs, comparer) {\r\n    return reduce((x, y) => ((comparer.Compare(y, x) > 0) ? x : y), xs);\r\n}\r\n\r\nexport function average(xs, averager) {\r\n    let count = 0;\r\n    return averager.DivideByInt(fold((acc, x) => {\r\n        count = ((count + 1) | 0);\r\n        return averager.Add(acc, x);\r\n    }, averager.GetZero(), xs), count);\r\n}\r\n\r\nexport function averageBy(f, xs, averager) {\r\n    let count = 0;\r\n    return averager.DivideByInt(fold((acc, x) => {\r\n        count = ((count + 1) | 0);\r\n        return averager.Add(acc, f(x));\r\n    }, averager.GetZero(), xs), count);\r\n}\r\n\r\nexport function permute(f, xs) {\r\n    return ofArray(permute_1(f, toArray(xs)));\r\n}\r\n\r\nexport function chunkBySize(chunkSize, xs) {\r\n    return ofArray(map_1((xs_1) => ofArray(xs_1), chunkBySize_1(chunkSize, toArray(xs))));\r\n}\r\n\r\nexport function allPairs(xs, ys) {\r\n    const root = FSharpList_get_Empty();\r\n    let node = root;\r\n    iterate((x) => {\r\n        iterate((y) => {\r\n            let xs_1, t;\r\n            node = ((xs_1 = node, (t = (new FSharpList([x, y], void 0)), (xs_1.tail = t, t))));\r\n        }, ys);\r\n    }, xs);\r\n    const xs_3 = node;\r\n    const t_2 = FSharpList_get_Empty();\r\n    xs_3.tail = t_2;\r\n    return FSharpList__get_Tail(root);\r\n}\r\n\r\nexport function skip(count_mut, xs_mut) {\r\n    skip:\r\n    while (true) {\r\n        const count = count_mut, xs = xs_mut;\r\n        if (count <= 0) {\r\n            return xs;\r\n        }\r\n        else if (FSharpList__get_IsEmpty(xs)) {\r\n            throw (new Error((SR_notEnoughElements + \"\\\\nParameter name: \") + \"list\"));\r\n        }\r\n        else {\r\n            count_mut = (count - 1);\r\n            xs_mut = FSharpList__get_Tail(xs);\r\n            continue skip;\r\n        }\r\n        break;\r\n    }\r\n}\r\n\r\nexport function skipWhile(predicate_mut, xs_mut) {\r\n    skipWhile:\r\n    while (true) {\r\n        const predicate = predicate_mut, xs = xs_mut;\r\n        if (FSharpList__get_IsEmpty(xs)) {\r\n            return xs;\r\n        }\r\n        else if (!predicate(FSharpList__get_Head(xs))) {\r\n            return xs;\r\n        }\r\n        else {\r\n            predicate_mut = predicate;\r\n            xs_mut = FSharpList__get_Tail(xs);\r\n            continue skipWhile;\r\n        }\r\n        break;\r\n    }\r\n}\r\n\r\nexport function take(count, xs) {\r\n    if (count < 0) {\r\n        throw (new Error((SR_inputMustBeNonNegative + \"\\\\nParameter name: \") + \"count\"));\r\n    }\r\n    const loop = (i_mut, acc_mut, xs_1_mut) => {\r\n        let t;\r\n        loop:\r\n        while (true) {\r\n            const i = i_mut, acc = acc_mut, xs_1 = xs_1_mut;\r\n            if (i <= 0) {\r\n                return acc;\r\n            }\r\n            else if (FSharpList__get_IsEmpty(xs_1)) {\r\n                throw (new Error((SR_notEnoughElements + \"\\\\nParameter name: \") + \"list\"));\r\n            }\r\n            else {\r\n                i_mut = (i - 1);\r\n                acc_mut = ((t = (new FSharpList(FSharpList__get_Head(xs_1), void 0)), (acc.tail = t, t)));\r\n                xs_1_mut = FSharpList__get_Tail(xs_1);\r\n                continue loop;\r\n            }\r\n            break;\r\n        }\r\n    };\r\n    const root = FSharpList_get_Empty();\r\n    const node = loop(count, root, xs);\r\n    const t_2 = FSharpList_get_Empty();\r\n    node.tail = t_2;\r\n    return FSharpList__get_Tail(root);\r\n}\r\n\r\nexport function takeWhile(predicate, xs) {\r\n    const loop = (acc_mut, xs_1_mut) => {\r\n        let t;\r\n        loop:\r\n        while (true) {\r\n            const acc = acc_mut, xs_1 = xs_1_mut;\r\n            if (FSharpList__get_IsEmpty(xs_1)) {\r\n                return acc;\r\n            }\r\n            else if (!predicate(FSharpList__get_Head(xs_1))) {\r\n                return acc;\r\n            }\r\n            else {\r\n                acc_mut = ((t = (new FSharpList(FSharpList__get_Head(xs_1), void 0)), (acc.tail = t, t)));\r\n                xs_1_mut = FSharpList__get_Tail(xs_1);\r\n                continue loop;\r\n            }\r\n            break;\r\n        }\r\n    };\r\n    const root = FSharpList_get_Empty();\r\n    const node = loop(root, xs);\r\n    const t_2 = FSharpList_get_Empty();\r\n    node.tail = t_2;\r\n    return FSharpList__get_Tail(root);\r\n}\r\n\r\nexport function truncate(count, xs) {\r\n    const loop = (i_mut, acc_mut, xs_1_mut) => {\r\n        let t;\r\n        loop:\r\n        while (true) {\r\n            const i = i_mut, acc = acc_mut, xs_1 = xs_1_mut;\r\n            if (i <= 0) {\r\n                return acc;\r\n            }\r\n            else if (FSharpList__get_IsEmpty(xs_1)) {\r\n                return acc;\r\n            }\r\n            else {\r\n                i_mut = (i - 1);\r\n                acc_mut = ((t = (new FSharpList(FSharpList__get_Head(xs_1), void 0)), (acc.tail = t, t)));\r\n                xs_1_mut = FSharpList__get_Tail(xs_1);\r\n                continue loop;\r\n            }\r\n            break;\r\n        }\r\n    };\r\n    const root = FSharpList_get_Empty();\r\n    const node = loop(count, root, xs);\r\n    const t_2 = FSharpList_get_Empty();\r\n    node.tail = t_2;\r\n    return FSharpList__get_Tail(root);\r\n}\r\n\r\nexport function getSlice(startIndex, endIndex, xs) {\r\n    const len = length(xs) | 0;\r\n    const startIndex_1 = defaultArg(startIndex, 0) | 0;\r\n    const endIndex_1 = defaultArg(endIndex, len - 1) | 0;\r\n    if (startIndex_1 < 0) {\r\n        throw (new Error((SR_indexOutOfBounds + \"\\\\nParameter name: \") + \"startIndex\"));\r\n    }\r\n    else if (endIndex_1 >= len) {\r\n        throw (new Error((SR_indexOutOfBounds + \"\\\\nParameter name: \") + \"endIndex\"));\r\n    }\r\n    else if (endIndex_1 < startIndex_1) {\r\n        return FSharpList_get_Empty();\r\n    }\r\n    else {\r\n        return take((endIndex_1 - startIndex_1) + 1, skip(startIndex_1, xs));\r\n    }\r\n}\r\n\r\nexport function splitAt(index, xs) {\r\n    if (index < 0) {\r\n        throw (new Error((SR_inputMustBeNonNegative + \"\\\\nParameter name: \") + \"index\"));\r\n    }\r\n    if (index > FSharpList__get_Length(xs)) {\r\n        throw (new Error((SR_notEnoughElements + \"\\\\nParameter name: \") + \"index\"));\r\n    }\r\n    return [take(index, xs), skip(index, xs)];\r\n}\r\n\r\nexport function exactlyOne(xs) {\r\n    if (FSharpList__get_IsEmpty(xs)) {\r\n        throw (new Error((SR_inputSequenceEmpty + \"\\\\nParameter name: \") + \"list\"));\r\n    }\r\n    else if (FSharpList__get_IsEmpty(FSharpList__get_Tail(xs))) {\r\n        return FSharpList__get_Head(xs);\r\n    }\r\n    else {\r\n        throw (new Error((SR_inputSequenceTooLong + \"\\\\nParameter name: \") + \"list\"));\r\n    }\r\n}\r\n\r\nexport function tryExactlyOne(xs) {\r\n    if ((!FSharpList__get_IsEmpty(xs)) ? FSharpList__get_IsEmpty(FSharpList__get_Tail(xs)) : false) {\r\n        return some(FSharpList__get_Head(xs));\r\n    }\r\n    else {\r\n        return void 0;\r\n    }\r\n}\r\n\r\nexport function where(predicate, xs) {\r\n    return filter(predicate, xs);\r\n}\r\n\r\nexport function pairwise(xs) {\r\n    return ofArray(pairwise_1(toArray(xs)));\r\n}\r\n\r\nexport function windowed(windowSize, xs) {\r\n    return ofArray(map_1((xs_1) => ofArray(xs_1), windowed_1(windowSize, toArray(xs))));\r\n}\r\n\r\nexport function splitInto(chunks, xs) {\r\n    return ofArray(map_1((xs_1) => ofArray(xs_1), splitInto_1(chunks, toArray(xs))));\r\n}\r\n\r\nexport function transpose(lists) {\r\n    return ofArray(map_1((xs_1) => ofArray(xs_1), transpose_1(map_1((xs) => toArray(xs), Array.from(lists)))));\r\n}\r\n\r\n","import { Union } from \"./.fable/fable-library.3.2.9/Types.js\";\r\nimport { int32_type, union_type, string_type } from \"./.fable/fable-library.3.2.9/Reflection.js\";\r\nimport { empty, cons, head, tail, isEmpty } from \"./.fable/fable-library.3.2.9/List.js\";\r\nimport { printf, toText } from \"./.fable/fable-library.3.2.9/String.js\";\r\n\r\nexport class Token extends Union {\r\n    constructor(tag, ...fields) {\r\n        super();\r\n        this.tag = (tag | 0);\r\n        this.fields = fields;\r\n    }\r\n    cases() {\r\n        return [\"L_BRACK\", \"R_BRACK\", \"IDENT\", \"COMMA\", \"OR\", \"AND\", \"NOT\", \"IMP\", \"BIMP\"];\r\n    }\r\n}\r\n\r\nexport function Token$reflection() {\r\n    return union_type(\"Lexer.Token\", [], Token, () => [[], [], [[\"Item\", string_type]], [], [], [], [], [], []]);\r\n}\r\n\r\nexport function format_token(token) {\r\n    switch (token.tag) {\r\n        case 1: {\r\n            return \")\";\r\n        }\r\n        case 2: {\r\n            const v = token.fields[0];\r\n            return v;\r\n        }\r\n        case 3: {\r\n            return \",\";\r\n        }\r\n        case 4: {\r\n            return \"\";\r\n        }\r\n        case 5: {\r\n            return \"\";\r\n        }\r\n        case 6: {\r\n            return \"\";\r\n        }\r\n        case 7: {\r\n            return \"\";\r\n        }\r\n        case 8: {\r\n            return \"\";\r\n        }\r\n        default: {\r\n            return \"(\";\r\n        }\r\n    }\r\n}\r\n\r\nexport class TokenAssoc extends Union {\r\n    constructor(tag, ...fields) {\r\n        super();\r\n        this.tag = (tag | 0);\r\n        this.fields = fields;\r\n    }\r\n    cases() {\r\n        return [\"LEFT\", \"RIGHT\", \"NA\"];\r\n    }\r\n}\r\n\r\nexport function TokenAssoc$reflection() {\r\n    return union_type(\"Lexer.TokenAssoc\", [], TokenAssoc, () => [[], [], []]);\r\n}\r\n\r\nexport class TokenArity extends Union {\r\n    constructor(tag, ...fields) {\r\n        super();\r\n        this.tag = (tag | 0);\r\n        this.fields = fields;\r\n    }\r\n    cases() {\r\n        return [\"UNARY\", \"BINARY\", \"NA\"];\r\n    }\r\n}\r\n\r\nexport function TokenArity$reflection() {\r\n    return union_type(\"Lexer.TokenArity\", [], TokenArity, () => [[], [], []]);\r\n}\r\n\r\nexport class TokenData extends Union {\r\n    constructor(tag, ...fields) {\r\n        super();\r\n        this.tag = (tag | 0);\r\n        this.fields = fields;\r\n    }\r\n    cases() {\r\n        return [\"TokenData\"];\r\n    }\r\n}\r\n\r\nexport function TokenData$reflection() {\r\n    return union_type(\"Lexer.TokenData\", [], TokenData, () => [[[\"Item1\", TokenAssoc$reflection()], [\"Item2\", int32_type], [\"Item3\", TokenArity$reflection()]]]);\r\n}\r\n\r\nexport function token_data(token_type) {\r\n    switch (token_type.tag) {\r\n        case 1: {\r\n            return new TokenData(0, new TokenAssoc(2), -1, new TokenArity(2));\r\n        }\r\n        case 2: {\r\n            return new TokenData(0, new TokenAssoc(2), -1, new TokenArity(2));\r\n        }\r\n        case 3: {\r\n            return new TokenData(0, new TokenAssoc(1), 1, new TokenArity(1));\r\n        }\r\n        case 4: {\r\n            return new TokenData(0, new TokenAssoc(0), 4, new TokenArity(1));\r\n        }\r\n        case 5: {\r\n            return new TokenData(0, new TokenAssoc(0), 5, new TokenArity(1));\r\n        }\r\n        case 6: {\r\n            return new TokenData(0, new TokenAssoc(1), 6, new TokenArity(0));\r\n        }\r\n        case 7: {\r\n            return new TokenData(0, new TokenAssoc(0), 3, new TokenArity(1));\r\n        }\r\n        case 8: {\r\n            return new TokenData(0, new TokenAssoc(0), 2, new TokenArity(1));\r\n        }\r\n        default: {\r\n            return new TokenData(0, new TokenAssoc(2), -1, new TokenArity(2));\r\n        }\r\n    }\r\n}\r\n\r\nexport function token_assoc(token_type) {\r\n    const assoc = token_data(token_type).fields[0];\r\n    return assoc;\r\n}\r\n\r\nexport function token_prec(token_type) {\r\n    const prec = token_data(token_type).fields[1] | 0;\r\n    return prec | 0;\r\n}\r\n\r\nexport function token_arity(token_type) {\r\n    const arity = token_data(token_type).fields[2];\r\n    return arity;\r\n}\r\n\r\nexport function tokenize(char_stream_mut) {\r\n    let c;\r\n    tokenize:\r\n    while (true) {\r\n        const char_stream = char_stream_mut;\r\n        if (!isEmpty(char_stream)) {\r\n            const t = tail(char_stream);\r\n            const h = head(char_stream);\r\n            if (h === \"\\t\") {\r\n                char_stream_mut = t;\r\n                continue tokenize;\r\n            }\r\n            else if (h === \"\\n\") {\r\n                char_stream_mut = t;\r\n                continue tokenize;\r\n            }\r\n            else if (h === \"\\r\") {\r\n                char_stream_mut = t;\r\n                continue tokenize;\r\n            }\r\n            else if (h === \" \") {\r\n                char_stream_mut = t;\r\n                continue tokenize;\r\n            }\r\n            else if (h === \"(\") {\r\n                return cons(new Token(0), tokenize(t));\r\n            }\r\n            else if (h === \")\") {\r\n                return cons(new Token(1), tokenize(t));\r\n            }\r\n            else if ((c = h, (c <= \"z\") ? (c >= \"a\") : false)) {\r\n                const c_1 = h;\r\n                return cons(new Token(2, c_1), tokenize(t));\r\n            }\r\n            else {\r\n                switch (h) {\r\n                    case \"\\u0026\": {\r\n                        return cons(new Token(5), tokenize(t));\r\n                    }\r\n                    case \",\": {\r\n                        return cons(new Token(3), tokenize(t));\r\n                    }\r\n                    case \"-\": {\r\n                        if (!isEmpty(t)) {\r\n                            const t_1 = tail(t);\r\n                            const h_1 = head(t);\r\n                            if (h_1 === \"\\u003e\") {\r\n                                return cons(new Token(7), tokenize(t_1));\r\n                            }\r\n                            else {\r\n                                throw (new Error(toText(printf(\"unexpected character %c\"))(h_1)));\r\n                            }\r\n                        }\r\n                        else {\r\n                            throw (new Error(toText(printf(\"unexpected character %c\"))(h)));\r\n                        }\r\n                    }\r\n                    case \"\\u003c\": {\r\n                        if (!isEmpty(t)) {\r\n                            const t_2 = tail(t);\r\n                            const h_2 = head(t);\r\n                            if (h_2 === \"-\") {\r\n                                if (!isEmpty(t_2)) {\r\n                                    const t_3 = tail(t_2);\r\n                                    const h_3 = head(t_2);\r\n                                    if (h_3 === \"\\u003e\") {\r\n                                        return cons(new Token(8), tokenize(t_3));\r\n                                    }\r\n                                    else {\r\n                                        throw (new Error(toText(printf(\"unexpected character %c\"))(h_3)));\r\n                                    }\r\n                                }\r\n                                else {\r\n                                    throw (new Error(toText(printf(\"unexpected character %c\"))(h_2)));\r\n                                }\r\n                            }\r\n                            else {\r\n                                throw (new Error(toText(printf(\"unexpected character %c\"))(h_2)));\r\n                            }\r\n                        }\r\n                        else {\r\n                            throw (new Error(toText(printf(\"unexpected character %c\"))(h)));\r\n                        }\r\n                    }\r\n                    case \"|\": {\r\n                        return cons(new Token(4), tokenize(t));\r\n                    }\r\n                    case \"~\": {\r\n                        return cons(new Token(6), tokenize(t));\r\n                    }\r\n                    default: {\r\n                        throw (new Error(toText(printf(\"unexpected character %c\"))(h)));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            return empty();\r\n        }\r\n        break;\r\n    }\r\n}\r\n\r\n","import { equals, isArrayLike, isDisposable, toIterator, getEnumerator } from \"./Util.js\";\r\nimport { toString } from \"./Types.js\";\r\nimport { class_type } from \"./Reflection.js\";\r\nimport { some, value as value_1 } from \"./Option.js\";\r\nimport { Operators_NullArg } from \"./FSharp.Core.js\";\r\nimport { chunkBySize as chunkBySize_1, permute as permute_1, transpose as transpose_1, windowed as windowed_1, splitInto as splitInto_1, map as map_1, pairwise as pairwise_1, scanBack as scanBack_1, reverse as reverse_1, mapFoldBack as mapFoldBack_1, mapFold as mapFold_1, tryItem as tryItem_1, tryHead as tryHead_1, foldBack2 as foldBack2_1, foldBack as foldBack_1, tryFindIndexBack as tryFindIndexBack_1, tryFindBack as tryFindBack_1, singleton as singleton_1 } from \"./Array.js\";\r\nimport { length as length_1, tryItem as tryItem_2, isEmpty as isEmpty_1, tryHead as tryHead_2, ofSeq as ofSeq_1, ofArray as ofArray_1, toArray as toArray_1, FSharpList } from \"./List.js\";\r\n\r\nexport const SR_enumerationAlreadyFinished = \"Enumeration already finished.\";\r\n\r\nexport const SR_enumerationNotStarted = \"Enumeration has not started. Call MoveNext.\";\r\n\r\nexport const SR_inputSequenceEmpty = \"The input sequence was empty.\";\r\n\r\nexport const SR_inputSequenceTooLong = \"The input sequence contains more than one element.\";\r\n\r\nexport const SR_keyNotFoundAlt = \"An index satisfying the predicate was not found in the collection.\";\r\n\r\nexport const SR_notEnoughElements = \"The input sequence has an insufficient number of elements.\";\r\n\r\nexport const SR_resetNotSupported = \"Reset is not supported on this enumerator.\";\r\n\r\nexport function Enumerator_noReset() {\r\n    throw (new Error(SR_resetNotSupported));\r\n}\r\n\r\nexport function Enumerator_notStarted() {\r\n    throw (new Error(SR_enumerationNotStarted));\r\n}\r\n\r\nexport function Enumerator_alreadyFinished() {\r\n    throw (new Error(SR_enumerationAlreadyFinished));\r\n}\r\n\r\nexport class Enumerator_Seq {\r\n    constructor(f) {\r\n        this.f = f;\r\n    }\r\n    toString() {\r\n        const xs = this;\r\n        const maxCount = 4;\r\n        let i = 0;\r\n        let str = \"seq [\";\r\n        const e = getEnumerator(xs);\r\n        try {\r\n            while ((i < maxCount) ? e[\"System.Collections.IEnumerator.MoveNext\"]() : false) {\r\n                if (i > 0) {\r\n                    str = (str + \"; \");\r\n                }\r\n                str = (str + toString(e[\"System.Collections.Generic.IEnumerator`1.get_Current\"]()));\r\n                i = ((i + 1) | 0);\r\n            }\r\n            if (i === maxCount) {\r\n                str = (str + \"; ...\");\r\n            }\r\n            return str + \"]\";\r\n        }\r\n        finally {\r\n            e.Dispose();\r\n        }\r\n    }\r\n    GetEnumerator() {\r\n        const x = this;\r\n        return x.f();\r\n    }\r\n    [Symbol.iterator]() {\r\n        return toIterator(this.GetEnumerator());\r\n    }\r\n    [\"System.Collections.IEnumerable.GetEnumerator\"]() {\r\n        const x = this;\r\n        return x.f();\r\n    }\r\n}\r\n\r\nexport function Enumerator_Seq$reflection(gen0) {\r\n    return class_type(\"SeqModule.Enumerator.Seq\", [gen0], Enumerator_Seq);\r\n}\r\n\r\nexport function Enumerator_Seq_$ctor_673A07F2(f) {\r\n    return new Enumerator_Seq(f);\r\n}\r\n\r\nexport class Enumerator_FromFunctions$1 {\r\n    constructor(current, next, dispose) {\r\n        this.current = current;\r\n        this.next = next;\r\n        this.dispose = dispose;\r\n    }\r\n    [\"System.Collections.Generic.IEnumerator`1.get_Current\"]() {\r\n        const __ = this;\r\n        return __.current();\r\n    }\r\n    [\"System.Collections.IEnumerator.get_Current\"]() {\r\n        const __ = this;\r\n        return __.current();\r\n    }\r\n    [\"System.Collections.IEnumerator.MoveNext\"]() {\r\n        const __ = this;\r\n        return __.next();\r\n    }\r\n    [\"System.Collections.IEnumerator.Reset\"]() {\r\n        Enumerator_noReset();\r\n    }\r\n    Dispose() {\r\n        const __ = this;\r\n        __.dispose();\r\n    }\r\n}\r\n\r\nexport function Enumerator_FromFunctions$1$reflection(gen0) {\r\n    return class_type(\"SeqModule.Enumerator.FromFunctions`1\", [gen0], Enumerator_FromFunctions$1);\r\n}\r\n\r\nexport function Enumerator_FromFunctions$1_$ctor_58C54629(current, next, dispose) {\r\n    return new Enumerator_FromFunctions$1(current, next, dispose);\r\n}\r\n\r\nexport function Enumerator_cast(e) {\r\n    return Enumerator_FromFunctions$1_$ctor_58C54629(() => e[\"System.Collections.IEnumerator.get_Current\"](), () => e[\"System.Collections.IEnumerator.MoveNext\"](), () => {\r\n        if (isDisposable(e)) {\r\n            e.Dispose();\r\n        }\r\n    });\r\n}\r\n\r\nexport function Enumerator_concat(sources) {\r\n    let outerOpt = void 0;\r\n    let innerOpt = void 0;\r\n    let started = false;\r\n    let finished = false;\r\n    let curr = void 0;\r\n    const finish = () => {\r\n        finished = true;\r\n        if (innerOpt != null) {\r\n            const inner = innerOpt;\r\n            try {\r\n                inner.Dispose();\r\n            }\r\n            finally {\r\n                innerOpt = (void 0);\r\n            }\r\n        }\r\n        if (outerOpt != null) {\r\n            const outer = outerOpt;\r\n            try {\r\n                outer.Dispose();\r\n            }\r\n            finally {\r\n                outerOpt = (void 0);\r\n            }\r\n        }\r\n    };\r\n    return Enumerator_FromFunctions$1_$ctor_58C54629(() => {\r\n        if (!started) {\r\n            Enumerator_notStarted();\r\n        }\r\n        else if (finished) {\r\n            Enumerator_alreadyFinished();\r\n        }\r\n        if (curr != null) {\r\n            return value_1(curr);\r\n        }\r\n        else {\r\n            return Enumerator_alreadyFinished();\r\n        }\r\n    }, () => {\r\n        let copyOfStruct;\r\n        if (!started) {\r\n            started = true;\r\n        }\r\n        if (finished) {\r\n            return false;\r\n        }\r\n        else {\r\n            let res = void 0;\r\n            while (res == null) {\r\n                const matchValue = [outerOpt, innerOpt];\r\n                if (matchValue[0] != null) {\r\n                    if (matchValue[1] != null) {\r\n                        const inner_1 = matchValue[1];\r\n                        if (inner_1[\"System.Collections.IEnumerator.MoveNext\"]()) {\r\n                            curr = some(inner_1[\"System.Collections.Generic.IEnumerator`1.get_Current\"]());\r\n                            res = true;\r\n                        }\r\n                        else {\r\n                            try {\r\n                                inner_1.Dispose();\r\n                            }\r\n                            finally {\r\n                                innerOpt = (void 0);\r\n                            }\r\n                        }\r\n                    }\r\n                    else {\r\n                        const outer_1 = matchValue[0];\r\n                        if (outer_1[\"System.Collections.IEnumerator.MoveNext\"]()) {\r\n                            const ie = outer_1[\"System.Collections.Generic.IEnumerator`1.get_Current\"]();\r\n                            innerOpt = ((copyOfStruct = ie, getEnumerator(copyOfStruct)));\r\n                        }\r\n                        else {\r\n                            finish();\r\n                            res = false;\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    outerOpt = getEnumerator(sources);\r\n                }\r\n            }\r\n            return value_1(res);\r\n        }\r\n    }, () => {\r\n        if (!finished) {\r\n            finish();\r\n        }\r\n    });\r\n}\r\n\r\nexport function Enumerator_enumerateThenFinally(f, e) {\r\n    return Enumerator_FromFunctions$1_$ctor_58C54629(() => e[\"System.Collections.Generic.IEnumerator`1.get_Current\"](), () => e[\"System.Collections.IEnumerator.MoveNext\"](), () => {\r\n        try {\r\n            e.Dispose();\r\n        }\r\n        finally {\r\n            f();\r\n        }\r\n    });\r\n}\r\n\r\nexport function Enumerator_generateWhileSome(openf, compute, closef) {\r\n    let started = false;\r\n    let curr = void 0;\r\n    let state = some(openf());\r\n    const dispose = () => {\r\n        if (state != null) {\r\n            const x_1 = value_1(state);\r\n            try {\r\n                closef(x_1);\r\n            }\r\n            finally {\r\n                state = (void 0);\r\n            }\r\n        }\r\n    };\r\n    const finish = () => {\r\n        try {\r\n            dispose();\r\n        }\r\n        finally {\r\n            curr = (void 0);\r\n        }\r\n    };\r\n    return Enumerator_FromFunctions$1_$ctor_58C54629(() => {\r\n        if (!started) {\r\n            Enumerator_notStarted();\r\n        }\r\n        if (curr != null) {\r\n            return value_1(curr);\r\n        }\r\n        else {\r\n            return Enumerator_alreadyFinished();\r\n        }\r\n    }, () => {\r\n        if (!started) {\r\n            started = true;\r\n        }\r\n        if (state != null) {\r\n            const s = value_1(state);\r\n            let matchValue_1;\r\n            try {\r\n                matchValue_1 = compute(s);\r\n            }\r\n            catch (matchValue) {\r\n                finish();\r\n                throw matchValue;\r\n            }\r\n            if (matchValue_1 != null) {\r\n                curr = matchValue_1;\r\n                return true;\r\n            }\r\n            else {\r\n                finish();\r\n                return false;\r\n            }\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }, dispose);\r\n}\r\n\r\nexport function Enumerator_unfold(f, state) {\r\n    let curr = void 0;\r\n    let acc = state;\r\n    return Enumerator_FromFunctions$1_$ctor_58C54629(() => {\r\n        if (curr != null) {\r\n            const x = curr[0];\r\n            const st = curr[1];\r\n            return x;\r\n        }\r\n        else {\r\n            return Enumerator_notStarted();\r\n        }\r\n    }, () => {\r\n        curr = f(acc);\r\n        if (curr != null) {\r\n            const x_1 = curr[0];\r\n            const st_1 = curr[1];\r\n            acc = st_1;\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }, () => {\r\n    });\r\n}\r\n\r\nexport function indexNotFound() {\r\n    throw (new Error(SR_keyNotFoundAlt));\r\n}\r\n\r\nexport function checkNonNull(argName, arg) {\r\n    if (arg == null) {\r\n        Operators_NullArg(argName);\r\n    }\r\n}\r\n\r\nexport function mkSeq(f) {\r\n    return Enumerator_Seq_$ctor_673A07F2(f);\r\n}\r\n\r\nexport function ofSeq(xs) {\r\n    checkNonNull(\"source\", xs);\r\n    return getEnumerator(xs);\r\n}\r\n\r\nexport function delay(generator) {\r\n    return mkSeq(() => getEnumerator(generator()));\r\n}\r\n\r\nexport function concat(sources) {\r\n    return mkSeq(() => Enumerator_concat(sources));\r\n}\r\n\r\nexport function unfold(generator, state) {\r\n    return mkSeq(() => Enumerator_unfold(generator, state));\r\n}\r\n\r\nexport function empty() {\r\n    return delay(() => (new Array(0)));\r\n}\r\n\r\nexport function singleton(x) {\r\n    return delay(() => singleton_1(x));\r\n}\r\n\r\nexport function ofArray(arr) {\r\n    return arr;\r\n}\r\n\r\nexport function toArray(xs) {\r\n    if (isArrayLike(xs)) {\r\n        return xs;\r\n    }\r\n    else if (xs instanceof FSharpList) {\r\n        return toArray_1(xs);\r\n    }\r\n    else {\r\n        return Array.from(xs);\r\n    }\r\n}\r\n\r\nexport function ofList(xs) {\r\n    return xs;\r\n}\r\n\r\nexport function toList(xs) {\r\n    if (isArrayLike(xs)) {\r\n        return ofArray_1(xs);\r\n    }\r\n    else if (xs instanceof FSharpList) {\r\n        return xs;\r\n    }\r\n    else {\r\n        return ofSeq_1(xs);\r\n    }\r\n}\r\n\r\nexport function generate(create, compute, dispose) {\r\n    return mkSeq(() => Enumerator_generateWhileSome(create, compute, dispose));\r\n}\r\n\r\nexport function generateIndexed(create, compute, dispose) {\r\n    return mkSeq(() => {\r\n        let i = -1;\r\n        return Enumerator_generateWhileSome(create, (x) => {\r\n            i = ((i + 1) | 0);\r\n            return compute(i, x);\r\n        }, dispose);\r\n    });\r\n}\r\n\r\nexport function append(xs, ys) {\r\n    return concat([xs, ys]);\r\n}\r\n\r\nexport function cast(xs) {\r\n    return mkSeq(() => {\r\n        checkNonNull(\"source\", xs);\r\n        return Enumerator_cast(getEnumerator(xs));\r\n    });\r\n}\r\n\r\nexport function choose(chooser, xs) {\r\n    return generate(() => ofSeq(xs), (e) => {\r\n        let curr = void 0;\r\n        while ((curr == null) ? e[\"System.Collections.IEnumerator.MoveNext\"]() : false) {\r\n            curr = chooser(e[\"System.Collections.Generic.IEnumerator`1.get_Current\"]());\r\n        }\r\n        return curr;\r\n    }, (e_1) => {\r\n        e_1.Dispose();\r\n    });\r\n}\r\n\r\nexport function compareWith(comparer, xs, ys) {\r\n    const e1 = ofSeq(xs);\r\n    try {\r\n        const e2 = ofSeq(ys);\r\n        try {\r\n            let c = 0;\r\n            let b1 = e1[\"System.Collections.IEnumerator.MoveNext\"]();\r\n            let b2 = e2[\"System.Collections.IEnumerator.MoveNext\"]();\r\n            while (((c === 0) ? b1 : false) ? b2 : false) {\r\n                c = (comparer(e1[\"System.Collections.Generic.IEnumerator`1.get_Current\"](), e2[\"System.Collections.Generic.IEnumerator`1.get_Current\"]()) | 0);\r\n                if (c === 0) {\r\n                    b1 = e1[\"System.Collections.IEnumerator.MoveNext\"]();\r\n                    b2 = e2[\"System.Collections.IEnumerator.MoveNext\"]();\r\n                }\r\n            }\r\n            return ((c !== 0) ? c : (b1 ? 1 : (b2 ? -1 : 0))) | 0;\r\n        }\r\n        finally {\r\n            e2.Dispose();\r\n        }\r\n    }\r\n    finally {\r\n        e1.Dispose();\r\n    }\r\n}\r\n\r\nexport function contains(value, xs, comparer) {\r\n    const e = ofSeq(xs);\r\n    try {\r\n        let found = false;\r\n        while ((!found) ? e[\"System.Collections.IEnumerator.MoveNext\"]() : false) {\r\n            found = comparer.Equals(value, e[\"System.Collections.Generic.IEnumerator`1.get_Current\"]());\r\n        }\r\n        return found;\r\n    }\r\n    finally {\r\n        e.Dispose();\r\n    }\r\n}\r\n\r\nexport function enumerateFromFunctions(create, moveNext, current) {\r\n    return generate(create, (x) => (moveNext(x) ? some(current(x)) : (void 0)), (x_1) => {\r\n        const matchValue = x_1;\r\n        if (isDisposable(matchValue)) {\r\n            matchValue.Dispose();\r\n        }\r\n    });\r\n}\r\n\r\nexport function enumerateThenFinally(source, compensation) {\r\n    const compensation_1 = compensation;\r\n    return mkSeq(() => {\r\n        try {\r\n            return Enumerator_enumerateThenFinally(compensation_1, ofSeq(source));\r\n        }\r\n        catch (matchValue) {\r\n            compensation_1();\r\n            throw matchValue;\r\n        }\r\n    });\r\n}\r\n\r\nexport function enumerateUsing(resource, source) {\r\n    const compensation = () => {\r\n        if (equals(resource, null)) {\r\n        }\r\n        else {\r\n            let copyOfStruct = resource;\r\n            copyOfStruct.Dispose();\r\n        }\r\n    };\r\n    return mkSeq(() => {\r\n        try {\r\n            return Enumerator_enumerateThenFinally(compensation, ofSeq(source(resource)));\r\n        }\r\n        catch (matchValue_1) {\r\n            compensation();\r\n            throw matchValue_1;\r\n        }\r\n    });\r\n}\r\n\r\nexport function enumerateWhile(guard, xs) {\r\n    return concat(unfold((i) => (guard() ? [xs, i + 1] : (void 0)), 0));\r\n}\r\n\r\nexport function filter(f, xs) {\r\n    return choose((x) => {\r\n        if (f(x)) {\r\n            return some(x);\r\n        }\r\n        else {\r\n            return void 0;\r\n        }\r\n    }, xs);\r\n}\r\n\r\nexport function exists(predicate, xs) {\r\n    const e = ofSeq(xs);\r\n    try {\r\n        let found = false;\r\n        while ((!found) ? e[\"System.Collections.IEnumerator.MoveNext\"]() : false) {\r\n            found = predicate(e[\"System.Collections.Generic.IEnumerator`1.get_Current\"]());\r\n        }\r\n        return found;\r\n    }\r\n    finally {\r\n        e.Dispose();\r\n    }\r\n}\r\n\r\nexport function exists2(predicate, xs, ys) {\r\n    const e1 = ofSeq(xs);\r\n    try {\r\n        const e2 = ofSeq(ys);\r\n        try {\r\n            let found = false;\r\n            while (((!found) ? e1[\"System.Collections.IEnumerator.MoveNext\"]() : false) ? e2[\"System.Collections.IEnumerator.MoveNext\"]() : false) {\r\n                found = predicate(e1[\"System.Collections.Generic.IEnumerator`1.get_Current\"](), e2[\"System.Collections.Generic.IEnumerator`1.get_Current\"]());\r\n            }\r\n            return found;\r\n        }\r\n        finally {\r\n            e2.Dispose();\r\n        }\r\n    }\r\n    finally {\r\n        e1.Dispose();\r\n    }\r\n}\r\n\r\nexport function exactlyOne(xs) {\r\n    const e = ofSeq(xs);\r\n    try {\r\n        if (e[\"System.Collections.IEnumerator.MoveNext\"]()) {\r\n            const v = e[\"System.Collections.Generic.IEnumerator`1.get_Current\"]();\r\n            if (e[\"System.Collections.IEnumerator.MoveNext\"]()) {\r\n                throw (new Error((SR_inputSequenceTooLong + \"\\\\nParameter name: \") + \"source\"));\r\n            }\r\n            else {\r\n                return v;\r\n            }\r\n        }\r\n        else {\r\n            throw (new Error((SR_inputSequenceEmpty + \"\\\\nParameter name: \") + \"source\"));\r\n        }\r\n    }\r\n    finally {\r\n        e.Dispose();\r\n    }\r\n}\r\n\r\nexport function tryExactlyOne(xs) {\r\n    const e = ofSeq(xs);\r\n    try {\r\n        if (e[\"System.Collections.IEnumerator.MoveNext\"]()) {\r\n            const v = e[\"System.Collections.Generic.IEnumerator`1.get_Current\"]();\r\n            return e[\"System.Collections.IEnumerator.MoveNext\"]() ? (void 0) : some(v);\r\n        }\r\n        else {\r\n            return void 0;\r\n        }\r\n    }\r\n    finally {\r\n        e.Dispose();\r\n    }\r\n}\r\n\r\nexport function tryFind(predicate, xs) {\r\n    const e = ofSeq(xs);\r\n    try {\r\n        let res = void 0;\r\n        while ((res == null) ? e[\"System.Collections.IEnumerator.MoveNext\"]() : false) {\r\n            const c = e[\"System.Collections.Generic.IEnumerator`1.get_Current\"]();\r\n            if (predicate(c)) {\r\n                res = some(c);\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n    finally {\r\n        e.Dispose();\r\n    }\r\n}\r\n\r\nexport function find(predicate, xs) {\r\n    const matchValue = tryFind(predicate, xs);\r\n    if (matchValue == null) {\r\n        return indexNotFound();\r\n    }\r\n    else {\r\n        return value_1(matchValue);\r\n    }\r\n}\r\n\r\nexport function tryFindBack(predicate, xs) {\r\n    return tryFindBack_1(predicate, toArray(xs));\r\n}\r\n\r\nexport function findBack(predicate, xs) {\r\n    const matchValue = tryFindBack(predicate, xs);\r\n    if (matchValue == null) {\r\n        return indexNotFound();\r\n    }\r\n    else {\r\n        return value_1(matchValue);\r\n    }\r\n}\r\n\r\nexport function tryFindIndex(predicate, xs) {\r\n    const e = ofSeq(xs);\r\n    try {\r\n        const loop = (i_mut) => {\r\n            loop:\r\n            while (true) {\r\n                const i = i_mut;\r\n                if (e[\"System.Collections.IEnumerator.MoveNext\"]()) {\r\n                    if (predicate(e[\"System.Collections.Generic.IEnumerator`1.get_Current\"]())) {\r\n                        return i;\r\n                    }\r\n                    else {\r\n                        i_mut = (i + 1);\r\n                        continue loop;\r\n                    }\r\n                }\r\n                else {\r\n                    return void 0;\r\n                }\r\n                break;\r\n            }\r\n        };\r\n        return loop(0);\r\n    }\r\n    finally {\r\n        e.Dispose();\r\n    }\r\n}\r\n\r\nexport function findIndex(predicate, xs) {\r\n    const matchValue = tryFindIndex(predicate, xs);\r\n    if (matchValue == null) {\r\n        return indexNotFound() | 0;\r\n    }\r\n    else {\r\n        return matchValue | 0;\r\n    }\r\n}\r\n\r\nexport function tryFindIndexBack(predicate, xs) {\r\n    return tryFindIndexBack_1(predicate, toArray(xs));\r\n}\r\n\r\nexport function findIndexBack(predicate, xs) {\r\n    const matchValue = tryFindIndexBack(predicate, xs);\r\n    if (matchValue == null) {\r\n        return indexNotFound() | 0;\r\n    }\r\n    else {\r\n        return matchValue | 0;\r\n    }\r\n}\r\n\r\nexport function fold(folder, state, xs) {\r\n    const e = ofSeq(xs);\r\n    try {\r\n        let acc = state;\r\n        while (e[\"System.Collections.IEnumerator.MoveNext\"]()) {\r\n            acc = folder(acc, e[\"System.Collections.Generic.IEnumerator`1.get_Current\"]());\r\n        }\r\n        return acc;\r\n    }\r\n    finally {\r\n        e.Dispose();\r\n    }\r\n}\r\n\r\nexport function foldBack(folder, xs, state) {\r\n    return foldBack_1(folder, toArray(xs), state);\r\n}\r\n\r\nexport function fold2(folder, state, xs, ys) {\r\n    const e1 = ofSeq(xs);\r\n    try {\r\n        const e2 = ofSeq(ys);\r\n        try {\r\n            let acc = state;\r\n            while (e1[\"System.Collections.IEnumerator.MoveNext\"]() ? e2[\"System.Collections.IEnumerator.MoveNext\"]() : false) {\r\n                acc = folder(acc, e1[\"System.Collections.Generic.IEnumerator`1.get_Current\"](), e2[\"System.Collections.Generic.IEnumerator`1.get_Current\"]());\r\n            }\r\n            return acc;\r\n        }\r\n        finally {\r\n            e2.Dispose();\r\n        }\r\n    }\r\n    finally {\r\n        e1.Dispose();\r\n    }\r\n}\r\n\r\nexport function foldBack2(folder, xs, ys, state) {\r\n    return foldBack2_1(folder, toArray(xs), toArray(ys), state);\r\n}\r\n\r\nexport function forAll(predicate, xs) {\r\n    return !exists((x) => (!predicate(x)), xs);\r\n}\r\n\r\nexport function forAll2(predicate, xs, ys) {\r\n    return !exists2((x, y) => (!predicate(x, y)), xs, ys);\r\n}\r\n\r\nexport function tryHead(xs) {\r\n    if (isArrayLike(xs)) {\r\n        return tryHead_1(xs);\r\n    }\r\n    else if (xs instanceof FSharpList) {\r\n        return tryHead_2(xs);\r\n    }\r\n    else {\r\n        const e = ofSeq(xs);\r\n        try {\r\n            return e[\"System.Collections.IEnumerator.MoveNext\"]() ? some(e[\"System.Collections.Generic.IEnumerator`1.get_Current\"]()) : (void 0);\r\n        }\r\n        finally {\r\n            e.Dispose();\r\n        }\r\n    }\r\n}\r\n\r\nexport function head(xs) {\r\n    const matchValue = tryHead(xs);\r\n    if (matchValue == null) {\r\n        throw (new Error((SR_inputSequenceEmpty + \"\\\\nParameter name: \") + \"source\"));\r\n    }\r\n    else {\r\n        return value_1(matchValue);\r\n    }\r\n}\r\n\r\nexport function initialize(count, f) {\r\n    return unfold((i) => ((i < count) ? [f(i), i + 1] : (void 0)), 0);\r\n}\r\n\r\nexport function initializeInfinite(f) {\r\n    return initialize(2147483647, f);\r\n}\r\n\r\nexport function isEmpty(xs) {\r\n    if (isArrayLike(xs)) {\r\n        return xs.length === 0;\r\n    }\r\n    else if (xs instanceof FSharpList) {\r\n        return isEmpty_1(xs);\r\n    }\r\n    else {\r\n        const e = ofSeq(xs);\r\n        try {\r\n            return !e[\"System.Collections.IEnumerator.MoveNext\"]();\r\n        }\r\n        finally {\r\n            e.Dispose();\r\n        }\r\n    }\r\n}\r\n\r\nexport function tryItem(index, xs) {\r\n    if (isArrayLike(xs)) {\r\n        return tryItem_1(index, xs);\r\n    }\r\n    else if (xs instanceof FSharpList) {\r\n        return tryItem_2(index, xs);\r\n    }\r\n    else {\r\n        const e = ofSeq(xs);\r\n        try {\r\n            const loop = (index_1_mut) => {\r\n                loop:\r\n                while (true) {\r\n                    const index_1 = index_1_mut;\r\n                    if (!e[\"System.Collections.IEnumerator.MoveNext\"]()) {\r\n                        return void 0;\r\n                    }\r\n                    else if (index_1 === 0) {\r\n                        return some(e[\"System.Collections.Generic.IEnumerator`1.get_Current\"]());\r\n                    }\r\n                    else {\r\n                        index_1_mut = (index_1 - 1);\r\n                        continue loop;\r\n                    }\r\n                    break;\r\n                }\r\n            };\r\n            return loop(index);\r\n        }\r\n        finally {\r\n            e.Dispose();\r\n        }\r\n    }\r\n}\r\n\r\nexport function item(index, xs) {\r\n    const matchValue = tryItem(index, xs);\r\n    if (matchValue == null) {\r\n        throw (new Error((SR_notEnoughElements + \"\\\\nParameter name: \") + \"index\"));\r\n    }\r\n    else {\r\n        return value_1(matchValue);\r\n    }\r\n}\r\n\r\nexport function iterate(action, xs) {\r\n    fold((unitVar0, x) => {\r\n        action(x);\r\n    }, void 0, xs);\r\n}\r\n\r\nexport function iterate2(action, xs, ys) {\r\n    fold2((unitVar0, x, y) => {\r\n        action(x, y);\r\n    }, void 0, xs, ys);\r\n}\r\n\r\nexport function iterateIndexed(action, xs) {\r\n    void fold((i, x) => {\r\n        action(i, x);\r\n        return (i + 1) | 0;\r\n    }, 0, xs);\r\n}\r\n\r\nexport function iterateIndexed2(action, xs, ys) {\r\n    void fold2((i, x, y) => {\r\n        action(i, x, y);\r\n        return (i + 1) | 0;\r\n    }, 0, xs, ys);\r\n}\r\n\r\nexport function tryLast(xs) {\r\n    const e = ofSeq(xs);\r\n    try {\r\n        const loop = (acc_mut) => {\r\n            loop:\r\n            while (true) {\r\n                const acc = acc_mut;\r\n                if (!e[\"System.Collections.IEnumerator.MoveNext\"]()) {\r\n                    return acc;\r\n                }\r\n                else {\r\n                    acc_mut = e[\"System.Collections.Generic.IEnumerator`1.get_Current\"]();\r\n                    continue loop;\r\n                }\r\n                break;\r\n            }\r\n        };\r\n        return e[\"System.Collections.IEnumerator.MoveNext\"]() ? some(loop(e[\"System.Collections.Generic.IEnumerator`1.get_Current\"]())) : (void 0);\r\n    }\r\n    finally {\r\n        e.Dispose();\r\n    }\r\n}\r\n\r\nexport function last(xs) {\r\n    const matchValue = tryLast(xs);\r\n    if (matchValue == null) {\r\n        throw (new Error((SR_notEnoughElements + \"\\\\nParameter name: \") + \"source\"));\r\n    }\r\n    else {\r\n        return value_1(matchValue);\r\n    }\r\n}\r\n\r\nexport function length(xs) {\r\n    if (isArrayLike(xs)) {\r\n        return xs.length | 0;\r\n    }\r\n    else if (xs instanceof FSharpList) {\r\n        return length_1(xs) | 0;\r\n    }\r\n    else {\r\n        const e = ofSeq(xs);\r\n        try {\r\n            let count = 0;\r\n            while (e[\"System.Collections.IEnumerator.MoveNext\"]()) {\r\n                count = ((count + 1) | 0);\r\n            }\r\n            return count | 0;\r\n        }\r\n        finally {\r\n            e.Dispose();\r\n        }\r\n    }\r\n}\r\n\r\nexport function map(mapping, xs) {\r\n    return generate(() => ofSeq(xs), (e) => (e[\"System.Collections.IEnumerator.MoveNext\"]() ? some(mapping(e[\"System.Collections.Generic.IEnumerator`1.get_Current\"]())) : (void 0)), (e_1) => {\r\n        e_1.Dispose();\r\n    });\r\n}\r\n\r\nexport function mapIndexed(mapping, xs) {\r\n    return generateIndexed(() => ofSeq(xs), (i, e) => (e[\"System.Collections.IEnumerator.MoveNext\"]() ? some(mapping(i, e[\"System.Collections.Generic.IEnumerator`1.get_Current\"]())) : (void 0)), (e_1) => {\r\n        e_1.Dispose();\r\n    });\r\n}\r\n\r\nexport function indexed(xs) {\r\n    return mapIndexed((i, x) => [i, x], xs);\r\n}\r\n\r\nexport function map2(mapping, xs, ys) {\r\n    return generate(() => [ofSeq(xs), ofSeq(ys)], (tupledArg) => {\r\n        const e1 = tupledArg[0];\r\n        const e2 = tupledArg[1];\r\n        return (e1[\"System.Collections.IEnumerator.MoveNext\"]() ? e2[\"System.Collections.IEnumerator.MoveNext\"]() : false) ? some(mapping(e1[\"System.Collections.Generic.IEnumerator`1.get_Current\"](), e2[\"System.Collections.Generic.IEnumerator`1.get_Current\"]())) : (void 0);\r\n    }, (tupledArg_1) => {\r\n        try {\r\n            tupledArg_1[0].Dispose();\r\n        }\r\n        finally {\r\n            tupledArg_1[1].Dispose();\r\n        }\r\n    });\r\n}\r\n\r\nexport function mapIndexed2(mapping, xs, ys) {\r\n    return generateIndexed(() => [ofSeq(xs), ofSeq(ys)], (i, tupledArg) => {\r\n        const e1 = tupledArg[0];\r\n        const e2 = tupledArg[1];\r\n        return (e1[\"System.Collections.IEnumerator.MoveNext\"]() ? e2[\"System.Collections.IEnumerator.MoveNext\"]() : false) ? some(mapping(i, e1[\"System.Collections.Generic.IEnumerator`1.get_Current\"](), e2[\"System.Collections.Generic.IEnumerator`1.get_Current\"]())) : (void 0);\r\n    }, (tupledArg_1) => {\r\n        try {\r\n            tupledArg_1[0].Dispose();\r\n        }\r\n        finally {\r\n            tupledArg_1[1].Dispose();\r\n        }\r\n    });\r\n}\r\n\r\nexport function map3(mapping, xs, ys, zs) {\r\n    return generate(() => [ofSeq(xs), ofSeq(ys), ofSeq(zs)], (tupledArg) => {\r\n        const e1 = tupledArg[0];\r\n        const e2 = tupledArg[1];\r\n        const e3 = tupledArg[2];\r\n        return ((e1[\"System.Collections.IEnumerator.MoveNext\"]() ? e2[\"System.Collections.IEnumerator.MoveNext\"]() : false) ? e3[\"System.Collections.IEnumerator.MoveNext\"]() : false) ? some(mapping(e1[\"System.Collections.Generic.IEnumerator`1.get_Current\"](), e2[\"System.Collections.Generic.IEnumerator`1.get_Current\"](), e3[\"System.Collections.Generic.IEnumerator`1.get_Current\"]())) : (void 0);\r\n    }, (tupledArg_1) => {\r\n        try {\r\n            tupledArg_1[0].Dispose();\r\n        }\r\n        finally {\r\n            try {\r\n                tupledArg_1[1].Dispose();\r\n            }\r\n            finally {\r\n                tupledArg_1[2].Dispose();\r\n            }\r\n        }\r\n    });\r\n}\r\n\r\nexport function readOnly(xs) {\r\n    checkNonNull(\"source\", xs);\r\n    return map((x) => x, xs);\r\n}\r\n\r\nexport function cache(xs) {\r\n    let cached = false;\r\n    const xsCache = [];\r\n    return delay(() => {\r\n        if (!cached) {\r\n            cached = true;\r\n            return map((x) => {\r\n                void (xsCache.push(x));\r\n                return x;\r\n            }, xs);\r\n        }\r\n        else {\r\n            return xsCache;\r\n        }\r\n    });\r\n}\r\n\r\nexport function allPairs(xs, ys) {\r\n    const ysCache = cache(ys);\r\n    return delay(() => concat(map((x) => map((y) => [x, y], ysCache), xs)));\r\n}\r\n\r\nexport function mapFold(mapping, state, xs) {\r\n    const patternInput = mapFold_1(mapping, state, toArray(xs));\r\n    return [readOnly(patternInput[0]), patternInput[1]];\r\n}\r\n\r\nexport function mapFoldBack(mapping, xs, state) {\r\n    const patternInput = mapFoldBack_1(mapping, toArray(xs), state);\r\n    return [readOnly(patternInput[0]), patternInput[1]];\r\n}\r\n\r\nexport function tryPick(chooser, xs) {\r\n    const e = ofSeq(xs);\r\n    try {\r\n        let res = void 0;\r\n        while ((res == null) ? e[\"System.Collections.IEnumerator.MoveNext\"]() : false) {\r\n            res = chooser(e[\"System.Collections.Generic.IEnumerator`1.get_Current\"]());\r\n        }\r\n        return res;\r\n    }\r\n    finally {\r\n        e.Dispose();\r\n    }\r\n}\r\n\r\nexport function pick(chooser, xs) {\r\n    const matchValue = tryPick(chooser, xs);\r\n    if (matchValue == null) {\r\n        return indexNotFound();\r\n    }\r\n    else {\r\n        return value_1(matchValue);\r\n    }\r\n}\r\n\r\nexport function reduce(folder, xs) {\r\n    const e = ofSeq(xs);\r\n    try {\r\n        const loop = (acc_mut) => {\r\n            loop:\r\n            while (true) {\r\n                const acc = acc_mut;\r\n                if (e[\"System.Collections.IEnumerator.MoveNext\"]()) {\r\n                    acc_mut = folder(acc, e[\"System.Collections.Generic.IEnumerator`1.get_Current\"]());\r\n                    continue loop;\r\n                }\r\n                else {\r\n                    return acc;\r\n                }\r\n                break;\r\n            }\r\n        };\r\n        if (e[\"System.Collections.IEnumerator.MoveNext\"]()) {\r\n            return loop(e[\"System.Collections.Generic.IEnumerator`1.get_Current\"]());\r\n        }\r\n        else {\r\n            throw (new Error(SR_inputSequenceEmpty));\r\n        }\r\n    }\r\n    finally {\r\n        e.Dispose();\r\n    }\r\n}\r\n\r\nexport function reduceBack(folder, xs) {\r\n    const arr = toArray(xs);\r\n    if (arr.length > 0) {\r\n        return arr.reduceRight(folder);\r\n    }\r\n    else {\r\n        throw (new Error(SR_inputSequenceEmpty));\r\n    }\r\n}\r\n\r\nexport function replicate(n, x) {\r\n    return initialize(n, (_arg1) => x);\r\n}\r\n\r\nexport function reverse(xs) {\r\n    return delay(() => ofArray(reverse_1(toArray(xs))));\r\n}\r\n\r\nexport function scan(folder, state, xs) {\r\n    return delay(() => {\r\n        let acc = state;\r\n        return concat([singleton(state), map((x) => {\r\n            acc = folder(acc, x);\r\n            return acc;\r\n        }, xs)]);\r\n    });\r\n}\r\n\r\nexport function scanBack(folder, xs, state) {\r\n    return delay(() => ofArray(scanBack_1(folder, toArray(xs), state)));\r\n}\r\n\r\nexport function skip(count, xs) {\r\n    return mkSeq(() => {\r\n        const e = ofSeq(xs);\r\n        try {\r\n            for (let i = 1; i <= count; i++) {\r\n                if (!e[\"System.Collections.IEnumerator.MoveNext\"]()) {\r\n                    throw (new Error((SR_notEnoughElements + \"\\\\nParameter name: \") + \"source\"));\r\n                }\r\n            }\r\n            return Enumerator_enumerateThenFinally(() => {\r\n            }, e);\r\n        }\r\n        catch (matchValue) {\r\n            e.Dispose();\r\n            throw matchValue;\r\n        }\r\n    });\r\n}\r\n\r\nexport function skipWhile(predicate, xs) {\r\n    return delay(() => {\r\n        let skipped = true;\r\n        return filter((x) => {\r\n            if (skipped) {\r\n                skipped = predicate(x);\r\n            }\r\n            return !skipped;\r\n        }, xs);\r\n    });\r\n}\r\n\r\nexport function tail(xs) {\r\n    return skip(1, xs);\r\n}\r\n\r\nexport function take(count, xs) {\r\n    return generateIndexed(() => ofSeq(xs), (i, e) => {\r\n        if (i < count) {\r\n            if (e[\"System.Collections.IEnumerator.MoveNext\"]()) {\r\n                return some(e[\"System.Collections.Generic.IEnumerator`1.get_Current\"]());\r\n            }\r\n            else {\r\n                throw (new Error((SR_notEnoughElements + \"\\\\nParameter name: \") + \"source\"));\r\n            }\r\n        }\r\n        else {\r\n            return void 0;\r\n        }\r\n    }, (e_1) => {\r\n        e_1.Dispose();\r\n    });\r\n}\r\n\r\nexport function takeWhile(predicate, xs) {\r\n    return generate(() => ofSeq(xs), (e) => ((e[\"System.Collections.IEnumerator.MoveNext\"]() ? predicate(e[\"System.Collections.Generic.IEnumerator`1.get_Current\"]()) : false) ? some(e[\"System.Collections.Generic.IEnumerator`1.get_Current\"]()) : (void 0)), (e_1) => {\r\n        e_1.Dispose();\r\n    });\r\n}\r\n\r\nexport function truncate(count, xs) {\r\n    return generateIndexed(() => ofSeq(xs), (i, e) => (((i < count) ? e[\"System.Collections.IEnumerator.MoveNext\"]() : false) ? some(e[\"System.Collections.Generic.IEnumerator`1.get_Current\"]()) : (void 0)), (e_1) => {\r\n        e_1.Dispose();\r\n    });\r\n}\r\n\r\nexport function zip(xs, ys) {\r\n    return map2((x, y) => [x, y], xs, ys);\r\n}\r\n\r\nexport function zip3(xs, ys, zs) {\r\n    return map3((x, y, z) => [x, y, z], xs, ys, zs);\r\n}\r\n\r\nexport function collect(mapping, xs) {\r\n    return delay(() => concat(map(mapping, xs)));\r\n}\r\n\r\nexport function where(predicate, xs) {\r\n    return filter(predicate, xs);\r\n}\r\n\r\nexport function pairwise(xs) {\r\n    return delay(() => ofArray(pairwise_1(toArray(xs))));\r\n}\r\n\r\nexport function splitInto(chunks, xs) {\r\n    return delay(() => ofArray(map_1((arr) => ofArray(arr), splitInto_1(chunks, toArray(xs)))));\r\n}\r\n\r\nexport function windowed(windowSize, xs) {\r\n    return delay(() => ofArray(map_1((arr) => ofArray(arr), windowed_1(windowSize, toArray(xs)))));\r\n}\r\n\r\nexport function transpose(xss) {\r\n    return delay(() => ofArray(map_1((arr) => ofArray(arr), transpose_1(map_1((xs_1) => toArray(xs_1), toArray(xss))))));\r\n}\r\n\r\nexport function sortWith(comparer, xs) {\r\n    return delay(() => {\r\n        const arr = toArray(xs);\r\n        arr.sort(comparer);\r\n        return ofArray(arr);\r\n    });\r\n}\r\n\r\nexport function sort(xs, comparer) {\r\n    return sortWith((x, y) => comparer.Compare(x, y), xs);\r\n}\r\n\r\nexport function sortBy(projection, xs, comparer) {\r\n    return sortWith((x, y) => comparer.Compare(projection(x), projection(y)), xs);\r\n}\r\n\r\nexport function sortDescending(xs, comparer) {\r\n    return sortWith((x, y) => (comparer.Compare(x, y) * -1), xs);\r\n}\r\n\r\nexport function sortByDescending(projection, xs, comparer) {\r\n    return sortWith((x, y) => (comparer.Compare(projection(x), projection(y)) * -1), xs);\r\n}\r\n\r\nexport function sum(xs, adder) {\r\n    return fold((acc, x) => adder.Add(acc, x), adder.GetZero(), xs);\r\n}\r\n\r\nexport function sumBy(f, xs, adder) {\r\n    return fold((acc, x) => adder.Add(acc, f(x)), adder.GetZero(), xs);\r\n}\r\n\r\nexport function maxBy(projection, xs, comparer) {\r\n    return reduce((x, y) => ((comparer.Compare(projection(y), projection(x)) > 0) ? y : x), xs);\r\n}\r\n\r\nexport function max(xs, comparer) {\r\n    return reduce((x, y) => ((comparer.Compare(y, x) > 0) ? y : x), xs);\r\n}\r\n\r\nexport function minBy(projection, xs, comparer) {\r\n    return reduce((x, y) => ((comparer.Compare(projection(y), projection(x)) > 0) ? x : y), xs);\r\n}\r\n\r\nexport function min(xs, comparer) {\r\n    return reduce((x, y) => ((comparer.Compare(y, x) > 0) ? x : y), xs);\r\n}\r\n\r\nexport function average(xs, averager) {\r\n    let count = 0;\r\n    const total = fold((acc, x) => {\r\n        count = ((count + 1) | 0);\r\n        return averager.Add(acc, x);\r\n    }, averager.GetZero(), xs);\r\n    if (count === 0) {\r\n        throw (new Error(\"The input sequence was empty\\\\nParameter name: xs\"));\r\n    }\r\n    else {\r\n        return averager.DivideByInt(total, count);\r\n    }\r\n}\r\n\r\nexport function averageBy(f, xs, averager) {\r\n    let count = 0;\r\n    const total = fold((acc, x) => {\r\n        count = ((count + 1) | 0);\r\n        return averager.Add(acc, f(x));\r\n    }, averager.GetZero(), xs);\r\n    if (count === 0) {\r\n        throw (new Error(\"The input sequence was empty\\\\nParameter name: xs\"));\r\n    }\r\n    else {\r\n        return averager.DivideByInt(total, count);\r\n    }\r\n}\r\n\r\nexport function permute(f, xs) {\r\n    return delay(() => ofArray(permute_1(f, toArray(xs))));\r\n}\r\n\r\nexport function chunkBySize(chunkSize, xs) {\r\n    return delay(() => ofArray(map_1((arr) => ofArray(arr), chunkBySize_1(chunkSize, toArray(xs)))));\r\n}\r\n\r\n","import { Union } from \"./.fable/fable-library.3.2.9/Types.js\";\r\nimport { format_token, token_prec, token_assoc, TokenArity, token_arity, Token$reflection } from \"./Lexer.fs.js\";\r\nimport { union_type } from \"./.fable/fable-library.3.2.9/Reflection.js\";\r\nimport { empty, cons, head, tail, isEmpty } from \"./.fable/fable-library.3.2.9/List.js\";\r\nimport { equals } from \"./.fable/fable-library.3.2.9/Util.js\";\r\nimport { printf, toText } from \"./.fable/fable-library.3.2.9/String.js\";\r\n\r\nexport class Node$ extends Union {\r\n    constructor(tag, ...fields) {\r\n        super();\r\n        this.tag = (tag | 0);\r\n        this.fields = fields;\r\n    }\r\n    cases() {\r\n        return [\"UnaryNode\", \"BinaryNode\", \"AtomNode\"];\r\n    }\r\n}\r\n\r\nexport function Node$$reflection() {\r\n    return union_type(\"Parser.Node\", [], Node$, () => [[[\"Item1\", Token$reflection()], [\"Item2\", Node$$reflection()]], [[\"Item1\", Token$reflection()], [\"Item2\", Node$$reflection()], [\"Item3\", Node$$reflection()]], [[\"Item\", Token$reflection()]]]);\r\n}\r\n\r\nexport function parse_helper(stack_mut, op_stack_mut, token_stream_mut) {\r\n    let op_t, op_op, op_t_2, op_op_2, op_t_7, op_op_6, op_t_5, op_op_4, op_t_11, op_op_10, op_t_9, op_op_8;\r\n    parse_helper:\r\n    while (true) {\r\n        const stack = stack_mut, op_stack = op_stack_mut, token_stream = token_stream_mut;\r\n        if (!isEmpty(token_stream)) {\r\n            const t_1 = tail(token_stream);\r\n            const op_1 = head(token_stream);\r\n            switch (op_1.tag) {\r\n                case 2: {\r\n                    const v = op_1.fields[0];\r\n                    stack_mut = cons(new Node$(2, op_1), stack);\r\n                    op_stack_mut = op_stack;\r\n                    token_stream_mut = t_1;\r\n                    continue parse_helper;\r\n                }\r\n                case 0: {\r\n                    stack_mut = stack;\r\n                    op_stack_mut = cons(op_1, op_stack);\r\n                    token_stream_mut = t_1;\r\n                    continue parse_helper;\r\n                }\r\n                case 1: {\r\n                    if (!isEmpty(op_stack)) {\r\n                        if ((op_t = tail(op_stack), (op_op = head(op_stack), equals(token_arity(op_op), new TokenArity(0))))) {\r\n                            const op_op_1 = head(op_stack);\r\n                            const op_t_1 = tail(op_stack);\r\n                            const operand_1 = head(stack);\r\n                            stack_mut = cons(new Node$(0, op_op_1, operand_1), tail(stack));\r\n                            op_stack_mut = op_t_1;\r\n                            token_stream_mut = cons(op_1, t_1);\r\n                            continue parse_helper;\r\n                        }\r\n                        else {\r\n                            let pattern_matching_result, op_op_3, op_t_3;\r\n                            if (!isEmpty(op_stack)) {\r\n                                if ((op_t_2 = tail(op_stack), (op_op_2 = head(op_stack), equals(token_arity(op_op_2), new TokenArity(1))))) {\r\n                                    pattern_matching_result = 0;\r\n                                    op_op_3 = head(op_stack);\r\n                                    op_t_3 = tail(op_stack);\r\n                                }\r\n                                else {\r\n                                    pattern_matching_result = 1;\r\n                                }\r\n                            }\r\n                            else {\r\n                                pattern_matching_result = 1;\r\n                            }\r\n                            switch (pattern_matching_result) {\r\n                                case 0: {\r\n                                    const right_1 = head(stack);\r\n                                    const left_1 = head(tail(stack));\r\n                                    stack_mut = cons(new Node$(1, op_op_3, left_1, right_1), tail(tail(stack)));\r\n                                    op_stack_mut = op_t_3;\r\n                                    token_stream_mut = cons(op_1, t_1);\r\n                                    continue parse_helper;\r\n                                }\r\n                                case 1: {\r\n                                    let pattern_matching_result_1, op_t_4;\r\n                                    if (!isEmpty(op_stack)) {\r\n                                        if (head(op_stack).tag === 0) {\r\n                                            pattern_matching_result_1 = 0;\r\n                                            op_t_4 = tail(op_stack);\r\n                                        }\r\n                                        else {\r\n                                            pattern_matching_result_1 = 1;\r\n                                        }\r\n                                    }\r\n                                    else {\r\n                                        pattern_matching_result_1 = 1;\r\n                                    }\r\n                                    switch (pattern_matching_result_1) {\r\n                                        case 0: {\r\n                                            stack_mut = stack;\r\n                                            op_stack_mut = op_t_4;\r\n                                            token_stream_mut = t_1;\r\n                                            continue parse_helper;\r\n                                        }\r\n                                        case 1: {\r\n                                            throw (new Error(\"unexpected )\"));\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    else {\r\n                        throw (new Error(\"unexpected )\"));\r\n                    }\r\n                }\r\n                default: {\r\n                    const matchValue_1 = token_assoc(op_1);\r\n                    switch (matchValue_1.tag) {\r\n                        case 0: {\r\n                            let pattern_matching_result_2, op_op_5, op_t_6;\r\n                            if (!isEmpty(op_stack)) {\r\n                                if ((op_t_5 = tail(op_stack), (op_op_4 = head(op_stack), token_prec(op_1) <= token_prec(op_op_4)))) {\r\n                                    pattern_matching_result_2 = 0;\r\n                                    op_op_5 = head(op_stack);\r\n                                    op_t_6 = tail(op_stack);\r\n                                }\r\n                                else {\r\n                                    pattern_matching_result_2 = 1;\r\n                                }\r\n                            }\r\n                            else {\r\n                                pattern_matching_result_2 = 1;\r\n                            }\r\n                            switch (pattern_matching_result_2) {\r\n                                case 0: {\r\n                                    const matchValue_2 = token_arity(op_op_5);\r\n                                    switch (matchValue_2.tag) {\r\n                                        case 1: {\r\n                                            const right_2 = head(stack);\r\n                                            const left_2 = head(tail(stack));\r\n                                            stack_mut = cons(new Node$(1, op_op_5, left_2, right_2), tail(tail(stack)));\r\n                                            op_stack_mut = op_t_6;\r\n                                            token_stream_mut = cons(op_1, t_1);\r\n                                            continue parse_helper;\r\n                                        }\r\n                                        case 2: {\r\n                                            throw (new Error(\"unexpected token\"));\r\n                                        }\r\n                                        default: {\r\n                                            const operand_2 = head(stack);\r\n                                            stack_mut = cons(new Node$(0, op_op_5, operand_2), tail(stack));\r\n                                            op_stack_mut = op_t_6;\r\n                                            token_stream_mut = cons(op_1, t_1);\r\n                                            continue parse_helper;\r\n                                        }\r\n                                    }\r\n                                }\r\n                                case 1: {\r\n                                    let pattern_matching_result_3;\r\n                                    if (isEmpty(op_stack)) {\r\n                                        pattern_matching_result_3 = 0;\r\n                                    }\r\n                                    else if (head(op_stack).tag === 0) {\r\n                                        pattern_matching_result_3 = 0;\r\n                                    }\r\n                                    else if ((op_t_7 = tail(op_stack), (op_op_6 = head(op_stack), token_prec(op_1) > token_prec(op_op_6)))) {\r\n                                        pattern_matching_result_3 = 1;\r\n                                    }\r\n                                    else {\r\n                                        pattern_matching_result_3 = 2;\r\n                                    }\r\n                                    switch (pattern_matching_result_3) {\r\n                                        case 0: {\r\n                                            stack_mut = stack;\r\n                                            op_stack_mut = cons(op_1, op_stack);\r\n                                            token_stream_mut = t_1;\r\n                                            continue parse_helper;\r\n                                        }\r\n                                        case 1: {\r\n                                            stack_mut = stack;\r\n                                            op_stack_mut = cons(op_1, op_stack);\r\n                                            token_stream_mut = t_1;\r\n                                            continue parse_helper;\r\n                                        }\r\n                                        case 2: {\r\n                                            throw (new Error(\"unexpected operator\"));\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                        case 1: {\r\n                            let pattern_matching_result_4, op_op_9, op_t_10;\r\n                            if (!isEmpty(op_stack)) {\r\n                                if ((op_t_9 = tail(op_stack), (op_op_8 = head(op_stack), token_prec(op_1) < token_prec(op_op_8)))) {\r\n                                    pattern_matching_result_4 = 0;\r\n                                    op_op_9 = head(op_stack);\r\n                                    op_t_10 = tail(op_stack);\r\n                                }\r\n                                else {\r\n                                    pattern_matching_result_4 = 1;\r\n                                }\r\n                            }\r\n                            else {\r\n                                pattern_matching_result_4 = 1;\r\n                            }\r\n                            switch (pattern_matching_result_4) {\r\n                                case 0: {\r\n                                    const matchValue_3 = token_arity(op_op_9);\r\n                                    switch (matchValue_3.tag) {\r\n                                        case 0: {\r\n                                            const operand_3 = head(stack);\r\n                                            stack_mut = cons(new Node$(0, op_op_9, operand_3), tail(stack));\r\n                                            op_stack_mut = op_t_10;\r\n                                            token_stream_mut = cons(op_1, t_1);\r\n                                            continue parse_helper;\r\n                                        }\r\n                                        case 1: {\r\n                                            const right_3 = head(stack);\r\n                                            const left_3 = head(tail(stack));\r\n                                            stack_mut = cons(new Node$(1, op_op_9, left_3, right_3), tail(tail(stack)));\r\n                                            op_stack_mut = op_t_10;\r\n                                            token_stream_mut = cons(op_1, t_1);\r\n                                            continue parse_helper;\r\n                                        }\r\n                                        default: {\r\n                                            throw (new Error(\"unexpected token\"));\r\n                                        }\r\n                                    }\r\n                                }\r\n                                case 1: {\r\n                                    let pattern_matching_result_5;\r\n                                    if (isEmpty(op_stack)) {\r\n                                        pattern_matching_result_5 = 0;\r\n                                    }\r\n                                    else if (head(op_stack).tag === 0) {\r\n                                        pattern_matching_result_5 = 0;\r\n                                    }\r\n                                    else if ((op_t_11 = tail(op_stack), (op_op_10 = head(op_stack), token_prec(op_1) >= token_prec(op_op_10)))) {\r\n                                        pattern_matching_result_5 = 1;\r\n                                    }\r\n                                    else {\r\n                                        pattern_matching_result_5 = 2;\r\n                                    }\r\n                                    switch (pattern_matching_result_5) {\r\n                                        case 0: {\r\n                                            stack_mut = stack;\r\n                                            op_stack_mut = cons(op_1, op_stack);\r\n                                            token_stream_mut = t_1;\r\n                                            continue parse_helper;\r\n                                        }\r\n                                        case 1: {\r\n                                            stack_mut = stack;\r\n                                            op_stack_mut = cons(op_1, op_stack);\r\n                                            token_stream_mut = t_1;\r\n                                            continue parse_helper;\r\n                                        }\r\n                                        case 2: {\r\n                                            throw (new Error(\"unexpected operator\"));\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                        default: {\r\n                            throw (new Error(\"unexpected operator\"));\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else if (!isEmpty(op_stack)) {\r\n            const t = tail(op_stack);\r\n            const op = head(op_stack);\r\n            const matchValue = token_arity(op);\r\n            switch (matchValue.tag) {\r\n                case 1: {\r\n                    const right = head(stack);\r\n                    const left = head(tail(stack));\r\n                    stack_mut = cons(new Node$(1, op, left, right), tail(tail(stack)));\r\n                    op_stack_mut = t;\r\n                    token_stream_mut = empty();\r\n                    continue parse_helper;\r\n                }\r\n                case 2: {\r\n                    throw (new Error(\"unexpected token\"));\r\n                }\r\n                default: {\r\n                    const operand = head(stack);\r\n                    stack_mut = cons(new Node$(0, op, operand), tail(stack));\r\n                    op_stack_mut = t;\r\n                    token_stream_mut = empty();\r\n                    continue parse_helper;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            return head(stack);\r\n        }\r\n        break;\r\n    }\r\n}\r\n\r\nexport function parse(token_stream) {\r\n    return parse_helper(empty(), empty(), token_stream);\r\n}\r\n\r\nexport function node_prec(node) {\r\n    let op_3;\r\n    switch (node.tag) {\r\n        case 1: {\r\n            const op_1 = node.fields[0];\r\n            op_3 = op_1;\r\n            break;\r\n        }\r\n        case 2: {\r\n            const op_2 = node.fields[0];\r\n            op_3 = op_2;\r\n            break;\r\n        }\r\n        default: {\r\n            const op = node.fields[0];\r\n            op_3 = op;\r\n        }\r\n    }\r\n    return token_prec(op_3) | 0;\r\n}\r\n\r\nexport function node_print(node) {\r\n    let op_prec_1, op_prec_2, operand, op, op_prec;\r\n    const prec = node_prec(node) | 0;\r\n    let pattern_matching_result, op_1, operand_1;\r\n    if (node.tag === 0) {\r\n        if ((operand = node.fields[1], (op = node.fields[0], (op_prec = (node_prec(operand) | 0), (prec > op_prec) ? (op_prec > 0) : false)))) {\r\n            pattern_matching_result = 0;\r\n            op_1 = node.fields[0];\r\n            operand_1 = node.fields[1];\r\n        }\r\n        else {\r\n            pattern_matching_result = 1;\r\n        }\r\n    }\r\n    else {\r\n        pattern_matching_result = 1;\r\n    }\r\n    switch (pattern_matching_result) {\r\n        case 0: {\r\n            const arg20 = node_print(operand_1);\r\n            const arg10 = format_token(op_1);\r\n            return toText(printf(\"%s(%s)\"))(arg10)(arg20);\r\n        }\r\n        case 1: {\r\n            switch (node.tag) {\r\n                case 1: {\r\n                    const right = node.fields[2];\r\n                    const op_3 = node.fields[0];\r\n                    const left = node.fields[1];\r\n                    let ls;\r\n                    if ((op_prec_1 = (node_prec(left) | 0), (prec > op_prec_1) ? (op_prec_1 > 0) : false)) {\r\n                        const arg10_2 = node_print(left);\r\n                        ls = toText(printf(\"(%s)\"))(arg10_2);\r\n                    }\r\n                    else {\r\n                        ls = node_print(left);\r\n                    }\r\n                    let rs;\r\n                    if ((op_prec_2 = (node_prec(right) | 0), (prec > op_prec_2) ? (op_prec_2 > 0) : false)) {\r\n                        const arg10_3 = node_print(right);\r\n                        rs = toText(printf(\"(%s)\"))(arg10_3);\r\n                    }\r\n                    else {\r\n                        rs = node_print(right);\r\n                    }\r\n                    const arg20_2 = format_token(op_3);\r\n                    return toText(printf(\"%s%s%s\"))(ls)(arg20_2)(rs);\r\n                }\r\n                case 2: {\r\n                    const op_4 = node.fields[0];\r\n                    const arg10_5 = format_token(op_4);\r\n                    return toText(printf(\"%s\"))(arg10_5);\r\n                }\r\n                default: {\r\n                    const operand_2 = node.fields[1];\r\n                    const op_2 = node.fields[0];\r\n                    const arg20_1 = node_print(operand_2);\r\n                    const arg10_1 = format_token(op_2);\r\n                    return toText(printf(\"%s%s\"))(arg10_1)(arg20_1);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n","import { empty, tail as tail_1, cons, head as head_1, isEmpty } from \"./.fable/fable-library.3.2.9/List.js\";\r\n\r\nexport function rev(list) {\r\n    const loop = (acc_mut, _arg1_mut) => {\r\n        loop:\r\n        while (true) {\r\n            const acc = acc_mut, _arg1 = _arg1_mut;\r\n            if (!isEmpty(_arg1)) {\r\n                acc_mut = cons(head_1(_arg1), acc);\r\n                _arg1_mut = tail_1(_arg1);\r\n                continue loop;\r\n            }\r\n            else {\r\n                return acc;\r\n            }\r\n            break;\r\n        }\r\n    };\r\n    return loop(empty(), list);\r\n}\r\n\r\n","import { Union } from \"./.fable/fable-library.3.2.9/Types.js\";\r\nimport { union_type, int32_type } from \"./.fable/fable-library.3.2.9/Reflection.js\";\r\nimport { Node$, node_print, Node$$reflection } from \"./Parser.fs.js\";\r\nimport { printf, toText } from \"./.fable/fable-library.3.2.9/String.js\";\r\nimport { Token } from \"./Lexer.fs.js\";\r\nimport { equals } from \"./.fable/fable-library.3.2.9/Util.js\";\r\nimport { ofArrayWithTail, empty, ofArray, singleton, append, cons, head, tail, isEmpty } from \"./.fable/fable-library.3.2.9/List.js\";\r\nimport { rev } from \"./Helper.fs.js\";\r\n\r\nexport class ProofLine extends Union {\r\n    constructor(tag, ...fields) {\r\n        super();\r\n        this.tag = (tag | 0);\r\n        this.fields = fields;\r\n    }\r\n    cases() {\r\n        return [\"PropositionLine\", \"NegElimLine\", \"AlphaLine\", \"BetaLine\", \"EtaLine\", \"OpenLine\", \"CloseLine\", \"BranchLine\"];\r\n    }\r\n}\r\n\r\nexport function ProofLine$reflection() {\r\n    return union_type(\"Propositional.ProofLine\", [], ProofLine, () => [[[\"Item1\", int32_type], [\"Item2\", Node$$reflection()]], [[\"Item1\", int32_type], [\"Item2\", ProofLine$reflection()], [\"Item3\", Node$$reflection()]], [[\"Item1\", int32_type], [\"Item2\", ProofLine$reflection()], [\"Item3\", Node$$reflection()]], [[\"Item1\", int32_type], [\"Item2\", ProofLine$reflection()], [\"Item3\", ProofLine$reflection()], [\"Item4\", Node$$reflection()]], [[\"Item1\", int32_type], [\"Item2\", ProofLine$reflection()], [\"Item3\", ProofLine$reflection()], [\"Item4\", Node$$reflection()]], [[\"Item\", int32_type]], [[\"Item1\", int32_type], [\"Item2\", ProofLine$reflection()], [\"Item3\", ProofLine$reflection()]], [[\"Item1\", int32_type], [\"Item2\", Node$$reflection()]]]);\r\n}\r\n\r\nexport class ProofTree extends Union {\r\n    constructor(tag, ...fields) {\r\n        super();\r\n        this.tag = (tag | 0);\r\n        this.fields = fields;\r\n    }\r\n    cases() {\r\n        return [\"End\", \"Continuous\", \"Branch\"];\r\n    }\r\n}\r\n\r\nexport function ProofTree$reflection() {\r\n    return union_type(\"Propositional.ProofTree\", [], ProofTree, () => [[[\"Item\", ProofLine$reflection()]], [[\"Item1\", ProofLine$reflection()], [\"Item2\", ProofTree$reflection()]], [[\"Item1\", ProofTree$reflection()], [\"Item2\", ProofTree$reflection()]]]);\r\n}\r\n\r\nexport class ProofBranchLine extends Union {\r\n    constructor(tag, ...fields) {\r\n        super();\r\n        this.tag = (tag | 0);\r\n        this.fields = fields;\r\n    }\r\n    cases() {\r\n        return [\"Root\", \"Line\"];\r\n    }\r\n}\r\n\r\nexport function ProofBranchLine$reflection() {\r\n    return union_type(\"Propositional.ProofBranchLine\", [], ProofBranchLine, () => [[], [[\"Item1\", ProofLine$reflection()], [\"Item2\", ProofBranchLine$reflection()]]]);\r\n}\r\n\r\nexport function get_line(line) {\r\n    switch (line.tag) {\r\n        case 1: {\r\n            const ln_1 = line.fields[0] | 0;\r\n            return ln_1 | 0;\r\n        }\r\n        case 2: {\r\n            const ln_2 = line.fields[0] | 0;\r\n            return ln_2 | 0;\r\n        }\r\n        case 3: {\r\n            const ln_3 = line.fields[0] | 0;\r\n            return ln_3 | 0;\r\n        }\r\n        case 4: {\r\n            const ln_4 = line.fields[0] | 0;\r\n            return ln_4 | 0;\r\n        }\r\n        case 5: {\r\n            const ln_5 = line.fields[0] | 0;\r\n            return ln_5 | 0;\r\n        }\r\n        case 6: {\r\n            const ln_6 = line.fields[0] | 0;\r\n            return ln_6 | 0;\r\n        }\r\n        case 7: {\r\n            const ln_7 = line.fields[0] | 0;\r\n            return ln_7 | 0;\r\n        }\r\n        default: {\r\n            const ln = line.fields[0] | 0;\r\n            return ln | 0;\r\n        }\r\n    }\r\n}\r\n\r\nexport function print_format_line(tab, formula) {\r\n    if (tab === 0) {\r\n        switch (formula.tag) {\r\n            case 1: {\r\n                const src = formula.fields[1];\r\n                const node_1 = formula.fields[2];\r\n                const ln_1 = formula.fields[0] | 0;\r\n                const src_ln = get_line(src) | 0;\r\n                const arg30 = node_print(node_1);\r\n                return toText(printf(\"%d: \\u003cDNE %d\\u003e: %s\\n\"))(ln_1)(src_ln)(arg30);\r\n            }\r\n            case 2: {\r\n                const src_1 = formula.fields[1];\r\n                const node_2 = formula.fields[2];\r\n                const ln_2 = formula.fields[0] | 0;\r\n                const src_ln_1 = get_line(src_1) | 0;\r\n                const arg30_1 = node_print(node_2);\r\n                return toText(printf(\"%d: \\u003cA %d\\u003e: %s\\n\"))(ln_2)(src_ln_1)(arg30_1);\r\n            }\r\n            case 3: {\r\n                const node_3 = formula.fields[3];\r\n                const ln_3 = formula.fields[0] | 0;\r\n                const beta_min = formula.fields[2];\r\n                const beta_max = formula.fields[1];\r\n                const bmax_ln = get_line(beta_max) | 0;\r\n                const bmin_ln = get_line(beta_min) | 0;\r\n                const arg40 = node_print(node_3);\r\n                return toText(printf(\"%d: \\u003cB %d %d\\u003e: %s\\n\"))(ln_3)(bmax_ln)(bmin_ln)(arg40);\r\n            }\r\n            case 4: {\r\n                const node_4 = formula.fields[3];\r\n                const ln_4 = formula.fields[0] | 0;\r\n                const eta_min = formula.fields[2];\r\n                const eta_max = formula.fields[1];\r\n                const emax_ln = get_line(eta_max) | 0;\r\n                const emin_ln = get_line(eta_min) | 0;\r\n                const arg40_1 = node_print(node_4);\r\n                return toText(printf(\"%d: \\u003cE %d %d\\u003e: %s\\n\"))(ln_4)(emax_ln)(emin_ln)(arg40_1);\r\n            }\r\n            case 5: {\r\n                const ln_5 = formula.fields[0] | 0;\r\n                return toText(printf(\"%d: \\u003cO\\u003e\\n\\n\"))(ln_5);\r\n            }\r\n            case 6: {\r\n                const ln_6 = formula.fields[0] | 0;\r\n                const close_min = formula.fields[2];\r\n                const close_max = formula.fields[1];\r\n                const cmax_ln = get_line(close_max) | 0;\r\n                const cmin_ln = get_line(close_min) | 0;\r\n                return toText(printf(\"%d: \\u003cC %d %d\\u003e\\n\\n\"))(ln_6)(cmax_ln)(cmin_ln);\r\n            }\r\n            case 7: {\r\n                const node_5 = formula.fields[1];\r\n                const ln_7 = formula.fields[0] | 0;\r\n                const arg20_6 = node_print(node_5);\r\n                return toText(printf(\"%d: \\u003cB\\u003e: %s\\n\"))(ln_7)(arg20_6);\r\n            }\r\n            default: {\r\n                const node = formula.fields[1];\r\n                const ln = formula.fields[0] | 0;\r\n                const arg20 = node_print(node);\r\n                return toText(printf(\"%d: \\u003cP\\u003e: %s\\n\"))(ln)(arg20);\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        const tab_1 = tab | 0;\r\n        const arg10_8 = print_format_line(tab_1 - 1, formula);\r\n        return toText(printf(\" %s\"))(arg10_8);\r\n    }\r\n}\r\n\r\nexport function print_format_tree(tab, tree) {\r\n    switch (tree.tag) {\r\n        case 1: {\r\n            const tree_1 = tree.fields[1];\r\n            const line_1 = tree.fields[0];\r\n            const arg20 = print_format_tree(tab, tree_1);\r\n            const arg10 = print_format_line(tab, line_1);\r\n            return toText(printf(\"%s%s\"))(arg10)(arg20);\r\n        }\r\n        case 2: {\r\n            const right = tree.fields[1];\r\n            const left = tree.fields[0];\r\n            const arg20_1 = print_format_tree(tab + 1, right);\r\n            const arg10_1 = print_format_tree(tab + 1, left);\r\n            return toText(printf(\"%s%s\"))(arg10_1)(arg20_1);\r\n        }\r\n        default: {\r\n            const line = tree.fields[0];\r\n            return print_format_line(tab, line);\r\n        }\r\n    }\r\n}\r\n\r\nexport function print_tree(tree) {\r\n    return print_format_tree(0, tree);\r\n}\r\n\r\nexport function json_from_tree_line(formula) {\r\n    switch (formula.tag) {\r\n        case 1: {\r\n            const src = formula.fields[1];\r\n            const node_1 = formula.fields[2];\r\n            const ln_1 = formula.fields[0] | 0;\r\n            const src_ln = get_line(src) | 0;\r\n            const arg30 = node_print(node_1);\r\n            return toText(printf(\"{\\\"type\\\": \\\"ne\\\", \\\"ln\\\": %d, \\\"src\\\": %d, \\\"formula\\\": \\\"%s\\\"}\"))(ln_1)(src_ln)(arg30);\r\n        }\r\n        case 2: {\r\n            const src_1 = formula.fields[1];\r\n            const node_2 = formula.fields[2];\r\n            const ln_2 = formula.fields[0] | 0;\r\n            const src_ln_1 = get_line(src_1) | 0;\r\n            const arg30_1 = node_print(node_2);\r\n            return toText(printf(\"{\\\"type\\\": \\\"a\\\", \\\"ln\\\": %d, \\\"src\\\": %d, \\\"formula\\\": \\\"%s\\\"}\"))(ln_2)(src_ln_1)(arg30_1);\r\n        }\r\n        case 3: {\r\n            const node_3 = formula.fields[3];\r\n            const ln_3 = formula.fields[0] | 0;\r\n            const beta_min = formula.fields[2];\r\n            const beta_max = formula.fields[1];\r\n            const bmax_ln = get_line(beta_max) | 0;\r\n            const bmin_ln = get_line(beta_min) | 0;\r\n            const arg40 = node_print(node_3);\r\n            return toText(printf(\"{\\\"type\\\": \\\"b\\\", \\\"ln\\\": %d, \\\"src\\\": %d, \\\"min_src\\\": %d, \\\"formula\\\": \\\"%s\\\"}\"))(ln_3)(bmax_ln)(bmin_ln)(arg40);\r\n        }\r\n        case 4: {\r\n            const node_4 = formula.fields[3];\r\n            const ln_4 = formula.fields[0] | 0;\r\n            const eta_min = formula.fields[2];\r\n            const eta_max = formula.fields[1];\r\n            const emax_ln = get_line(eta_max) | 0;\r\n            const emin_ln = get_line(eta_min) | 0;\r\n            const arg40_1 = node_print(node_4);\r\n            return toText(printf(\"{\\\"type\\\": \\\"e\\\", \\\"ln\\\": %d, \\\"src\\\": %d, \\\"min_src\\\": %d, \\\"formula\\\": \\\"%s\\\"}\"))(ln_4)(emax_ln)(emin_ln)(arg40_1);\r\n        }\r\n        case 5: {\r\n            const ln_5 = formula.fields[0] | 0;\r\n            return toText(printf(\"{\\\"type\\\": \\\"o\\\", \\\"ln\\\": %d}\"))(ln_5);\r\n        }\r\n        case 6: {\r\n            const ln_6 = formula.fields[0] | 0;\r\n            const close_min = formula.fields[2];\r\n            const close_max = formula.fields[1];\r\n            const cmax_ln = get_line(close_max) | 0;\r\n            const cmin_ln = get_line(close_min) | 0;\r\n            return toText(printf(\"{\\\"type\\\": \\\"c\\\", \\\"ln\\\": %d, \\\"src\\\": %d, \\\"min_src\\\": %d}\"))(ln_6)(cmax_ln)(cmin_ln);\r\n        }\r\n        case 7: {\r\n            const node_5 = formula.fields[1];\r\n            const ln_7 = formula.fields[0] | 0;\r\n            const arg20_6 = node_print(node_5);\r\n            return toText(printf(\"{\\\"type\\\": \\\"br\\\", \\\"ln\\\": %d, \\\"formula\\\": \\\"%s\\\"}\"))(ln_7)(arg20_6);\r\n        }\r\n        default: {\r\n            const node = formula.fields[1];\r\n            const ln = formula.fields[0] | 0;\r\n            const arg20 = node_print(node);\r\n            return toText(printf(\"{\\\"type\\\": \\\"p\\\", \\\"ln\\\": %d, \\\"formula\\\": \\\"%s\\\"}\"))(ln)(arg20);\r\n        }\r\n    }\r\n}\r\n\r\nexport function json_from_tree_helper(tree) {\r\n    switch (tree.tag) {\r\n        case 1: {\r\n            const tree_1 = tree.fields[1];\r\n            const line_1 = tree.fields[0];\r\n            const arg20 = json_from_tree_helper(tree_1);\r\n            const arg10 = json_from_tree_line(line_1);\r\n            return toText(printf(\"%s, %s\"))(arg10)(arg20);\r\n        }\r\n        case 2: {\r\n            const right = tree.fields[1];\r\n            const left = tree.fields[0];\r\n            const arg20_1 = json_from_tree_helper(right);\r\n            const arg10_1 = json_from_tree_helper(left);\r\n            return toText(printf(\"{\\\"type\\\": \\\"bc\\\", \\\"left\\\": [%s], \\\"right\\\": [%s]}\"))(arg10_1)(arg20_1);\r\n        }\r\n        default: {\r\n            const line = tree.fields[0];\r\n            return json_from_tree_line(line);\r\n        }\r\n    }\r\n}\r\n\r\nexport function json_from_tree(tree) {\r\n    return (\"[\" + json_from_tree_helper(tree)) + \"]\";\r\n}\r\n\r\nexport function remove_neg(node_mut) {\r\n    remove_neg:\r\n    while (true) {\r\n        const node = node_mut;\r\n        let pattern_matching_result, operand;\r\n        if (node.tag === 0) {\r\n            if (node.fields[0].tag === 6) {\r\n                if (node.fields[1].tag === 0) {\r\n                    if (node.fields[1].fields[0].tag === 6) {\r\n                        pattern_matching_result = 0;\r\n                        operand = node.fields[1].fields[1];\r\n                    }\r\n                    else {\r\n                        pattern_matching_result = 1;\r\n                    }\r\n                }\r\n                else {\r\n                    pattern_matching_result = 1;\r\n                }\r\n            }\r\n            else {\r\n                pattern_matching_result = 1;\r\n            }\r\n        }\r\n        else {\r\n            pattern_matching_result = 1;\r\n        }\r\n        switch (pattern_matching_result) {\r\n            case 0: {\r\n                node_mut = operand;\r\n                continue remove_neg;\r\n            }\r\n            case 1: {\r\n                return node;\r\n            }\r\n        }\r\n        break;\r\n    }\r\n}\r\n\r\nexport function negate(node) {\r\n    return remove_neg(new Node$(0, new Token(6), node));\r\n}\r\n\r\nexport function in_branch(node_mut, line_mut) {\r\n    let ln_10, l_node_10, ln_8, l_node_8, b_2, a_6, ln_6, l_node_6, b, a_4, ln_4, l_node_4, a_2, ln_2, l_node_2, a, ln, l_node;\r\n    in_branch:\r\n    while (true) {\r\n        const node = node_mut, line = line_mut;\r\n        let pattern_matching_result, l_node_1, ln_1;\r\n        if (line.tag === 1) {\r\n            if (line.fields[0].tag === 0) {\r\n                if ((ln = (line.fields[0].fields[0] | 0), (l_node = line.fields[0].fields[1], equals(l_node, node)))) {\r\n                    pattern_matching_result = 1;\r\n                    l_node_1 = line.fields[0].fields[1];\r\n                    ln_1 = line.fields[0].fields[0];\r\n                }\r\n                else {\r\n                    pattern_matching_result = 2;\r\n                }\r\n            }\r\n            else {\r\n                pattern_matching_result = 2;\r\n            }\r\n        }\r\n        else {\r\n            pattern_matching_result = 0;\r\n        }\r\n        switch (pattern_matching_result) {\r\n            case 0: {\r\n                return void 0;\r\n            }\r\n            case 1: {\r\n                return new ProofLine(0, ln_1, l_node_1);\r\n            }\r\n            case 2: {\r\n                let pattern_matching_result_1, a_1, l_node_3, ln_3;\r\n                if (line.tag === 1) {\r\n                    if (line.fields[0].tag === 1) {\r\n                        if ((ln_2 = (line.fields[0].fields[0] | 0), (l_node_2 = line.fields[0].fields[2], (a = line.fields[0].fields[1], equals(l_node_2, node))))) {\r\n                            pattern_matching_result_1 = 0;\r\n                            a_1 = line.fields[0].fields[1];\r\n                            l_node_3 = line.fields[0].fields[2];\r\n                            ln_3 = line.fields[0].fields[0];\r\n                        }\r\n                        else {\r\n                            pattern_matching_result_1 = 1;\r\n                        }\r\n                    }\r\n                    else {\r\n                        pattern_matching_result_1 = 1;\r\n                    }\r\n                }\r\n                else {\r\n                    pattern_matching_result_1 = 1;\r\n                }\r\n                switch (pattern_matching_result_1) {\r\n                    case 0: {\r\n                        return new ProofLine(1, ln_3, a_1, l_node_3);\r\n                    }\r\n                    case 1: {\r\n                        let pattern_matching_result_2, a_3, l_node_5, ln_5;\r\n                        if (line.tag === 1) {\r\n                            if (line.fields[0].tag === 2) {\r\n                                if ((ln_4 = (line.fields[0].fields[0] | 0), (l_node_4 = line.fields[0].fields[2], (a_2 = line.fields[0].fields[1], equals(l_node_4, node))))) {\r\n                                    pattern_matching_result_2 = 0;\r\n                                    a_3 = line.fields[0].fields[1];\r\n                                    l_node_5 = line.fields[0].fields[2];\r\n                                    ln_5 = line.fields[0].fields[0];\r\n                                }\r\n                                else {\r\n                                    pattern_matching_result_2 = 1;\r\n                                }\r\n                            }\r\n                            else {\r\n                                pattern_matching_result_2 = 1;\r\n                            }\r\n                        }\r\n                        else {\r\n                            pattern_matching_result_2 = 1;\r\n                        }\r\n                        switch (pattern_matching_result_2) {\r\n                            case 0: {\r\n                                return new ProofLine(2, ln_5, a_3, l_node_5);\r\n                            }\r\n                            case 1: {\r\n                                let pattern_matching_result_3, a_5, b_1, l_node_7, ln_7;\r\n                                if (line.tag === 1) {\r\n                                    if (line.fields[0].tag === 3) {\r\n                                        if ((ln_6 = (line.fields[0].fields[0] | 0), (l_node_6 = line.fields[0].fields[3], (b = line.fields[0].fields[2], (a_4 = line.fields[0].fields[1], equals(l_node_6, node)))))) {\r\n                                            pattern_matching_result_3 = 0;\r\n                                            a_5 = line.fields[0].fields[1];\r\n                                            b_1 = line.fields[0].fields[2];\r\n                                            l_node_7 = line.fields[0].fields[3];\r\n                                            ln_7 = line.fields[0].fields[0];\r\n                                        }\r\n                                        else {\r\n                                            pattern_matching_result_3 = 1;\r\n                                        }\r\n                                    }\r\n                                    else {\r\n                                        pattern_matching_result_3 = 1;\r\n                                    }\r\n                                }\r\n                                else {\r\n                                    pattern_matching_result_3 = 1;\r\n                                }\r\n                                switch (pattern_matching_result_3) {\r\n                                    case 0: {\r\n                                        return new ProofLine(3, ln_7, a_5, b_1, l_node_7);\r\n                                    }\r\n                                    case 1: {\r\n                                        let pattern_matching_result_4, a_7, b_3, l_node_9, ln_9;\r\n                                        if (line.tag === 1) {\r\n                                            if (line.fields[0].tag === 4) {\r\n                                                if ((ln_8 = (line.fields[0].fields[0] | 0), (l_node_8 = line.fields[0].fields[3], (b_2 = line.fields[0].fields[2], (a_6 = line.fields[0].fields[1], equals(l_node_8, node)))))) {\r\n                                                    pattern_matching_result_4 = 0;\r\n                                                    a_7 = line.fields[0].fields[1];\r\n                                                    b_3 = line.fields[0].fields[2];\r\n                                                    l_node_9 = line.fields[0].fields[3];\r\n                                                    ln_9 = line.fields[0].fields[0];\r\n                                                }\r\n                                                else {\r\n                                                    pattern_matching_result_4 = 1;\r\n                                                }\r\n                                            }\r\n                                            else {\r\n                                                pattern_matching_result_4 = 1;\r\n                                            }\r\n                                        }\r\n                                        else {\r\n                                            pattern_matching_result_4 = 1;\r\n                                        }\r\n                                        switch (pattern_matching_result_4) {\r\n                                            case 0: {\r\n                                                return new ProofLine(4, ln_9, a_7, b_3, l_node_9);\r\n                                            }\r\n                                            case 1: {\r\n                                                let pattern_matching_result_5, l_node_11, ln_11;\r\n                                                if (line.tag === 1) {\r\n                                                    if (line.fields[0].tag === 7) {\r\n                                                        if ((ln_10 = (line.fields[0].fields[0] | 0), (l_node_10 = line.fields[0].fields[1], equals(l_node_10, node)))) {\r\n                                                            pattern_matching_result_5 = 0;\r\n                                                            l_node_11 = line.fields[0].fields[1];\r\n                                                            ln_11 = line.fields[0].fields[0];\r\n                                                        }\r\n                                                        else {\r\n                                                            pattern_matching_result_5 = 1;\r\n                                                        }\r\n                                                    }\r\n                                                    else {\r\n                                                        pattern_matching_result_5 = 1;\r\n                                                    }\r\n                                                }\r\n                                                else {\r\n                                                    pattern_matching_result_5 = 1;\r\n                                                }\r\n                                                switch (pattern_matching_result_5) {\r\n                                                    case 0: {\r\n                                                        return new ProofLine(7, ln_11, l_node_11);\r\n                                                    }\r\n                                                    case 1: {\r\n                                                        if (line.tag === 1) {\r\n                                                            const prev = line.fields[1];\r\n                                                            node_mut = node;\r\n                                                            line_mut = prev;\r\n                                                            continue in_branch;\r\n                                                        }\r\n                                                        else {\r\n                                                            throw (new Error(\"Match failure\"));\r\n                                                        }\r\n                                                    }\r\n                                                }\r\n                                            }\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        break;\r\n    }\r\n}\r\n\r\nexport function neg_in_branch(node, line) {\r\n    return in_branch(negate(node), line);\r\n}\r\n\r\nexport function prop_helper(ln_mut, nodes_mut, passed_mut, tree_mut) {\r\n    let op_1;\r\n    prop_helper:\r\n    while (true) {\r\n        const ln = ln_mut, nodes = nodes_mut, passed = passed_mut, tree = tree_mut;\r\n        let prev;\r\n        if (tree.tag === 1) {\r\n            const line = tree.fields[0];\r\n            prev = line;\r\n        }\r\n        else {\r\n            prev = (void 0);\r\n        }\r\n        if (!isEmpty(nodes)) {\r\n            const nodes_1 = tail(nodes);\r\n            const node_1 = head(nodes);\r\n            const matchValue = neg_in_branch(node_1, tree);\r\n            if (matchValue == null) {\r\n                switch (node_1.tag) {\r\n                    case 0: {\r\n                        const operand = node_1.fields[1];\r\n                        const op_3 = node_1.fields[0];\r\n                        if (op_3.tag === 6) {\r\n                            switch (operand.tag) {\r\n                                case 0: {\r\n                                    const operand_1 = operand.fields[1];\r\n                                    const op_5 = operand.fields[0];\r\n                                    if (op_5.tag === 6) {\r\n                                        const new_node = remove_neg(operand_1);\r\n                                        let prev_instr_line;\r\n                                        const matchValue_1 = in_branch(node_1, tree);\r\n                                        if (matchValue_1 != null) {\r\n                                            const prev_2 = matchValue_1;\r\n                                            prev_instr_line = prev_2;\r\n                                        }\r\n                                        else {\r\n                                            throw (new Error(\"This should be unreachable.\"));\r\n                                        }\r\n                                        const instr = new ProofLine(1, ln, prev_instr_line, new_node);\r\n                                        const down_tree_1 = new ProofBranchLine(1, instr, tree);\r\n                                        const up_tree_1 = prop_helper(ln + 1, cons(new_node, nodes_1), passed, down_tree_1);\r\n                                        return new ProofTree(1, instr, up_tree_1);\r\n                                    }\r\n                                    else {\r\n                                        throw (new Error(\"This should be unreachable\"));\r\n                                    }\r\n                                }\r\n                                case 2: {\r\n                                    ln_mut = ln;\r\n                                    nodes_mut = nodes_1;\r\n                                    passed_mut = passed;\r\n                                    tree_mut = tree;\r\n                                    continue prop_helper;\r\n                                }\r\n                                default: {\r\n                                    const right_1 = operand.fields[2];\r\n                                    const op_4 = operand.fields[0];\r\n                                    const left_2 = operand.fields[1];\r\n                                    switch (op_4.tag) {\r\n                                        case 3: {\r\n                                            throw (new Error(\"This should be unreachable.\"));\r\n                                        }\r\n                                        case 5: {\r\n                                            return beta_helper(ln, nodes_1, passed, tree, node_1, negate(left_2), negate(right_1));\r\n                                        }\r\n                                        case 4: {\r\n                                            return alpha_helper(ln, nodes_1, passed, tree, node_1, negate(left_2), negate(right_1));\r\n                                        }\r\n                                        case 7: {\r\n                                            return alpha_helper(ln, nodes_1, passed, tree, node_1, left_2, negate(right_1));\r\n                                        }\r\n                                        case 8: {\r\n                                            return eta_helper(ln, nodes_1, passed, tree, node_1, left_2, negate(right_1));\r\n                                        }\r\n                                        default: {\r\n                                            throw (new Error(\"This should be unreachable.\"));\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                        else {\r\n                            throw (new Error(\"This should be unreachable.\"));\r\n                        }\r\n                    }\r\n                    case 2: {\r\n                        ln_mut = ln;\r\n                        nodes_mut = nodes_1;\r\n                        passed_mut = passed;\r\n                        tree_mut = tree;\r\n                        continue prop_helper;\r\n                    }\r\n                    default: {\r\n                        const right = node_1.fields[2];\r\n                        const op = node_1.fields[0];\r\n                        const left_1 = node_1.fields[1];\r\n                        switch (op.tag) {\r\n                            case 3: {\r\n                                const instr_line = new ProofLine(0, ln, left_1);\r\n                                const down_tree = new ProofBranchLine(1, instr_line, tree);\r\n                                let pattern_matching_result;\r\n                                if (right.tag === 1) {\r\n                                    if ((op_1 = right.fields[0], equals(op_1, new Token(3)))) {\r\n                                        pattern_matching_result = 0;\r\n                                    }\r\n                                    else {\r\n                                        pattern_matching_result = 1;\r\n                                    }\r\n                                }\r\n                                else {\r\n                                    pattern_matching_result = 1;\r\n                                }\r\n                                switch (pattern_matching_result) {\r\n                                    case 0: {\r\n                                        const next_up_tree = prop_helper(ln + 1, append(nodes_1, singleton(right)), cons(left_1, passed), down_tree);\r\n                                        return new ProofTree(1, instr_line, next_up_tree);\r\n                                    }\r\n                                    case 1: {\r\n                                        const next_instr_line = new ProofLine(0, ln + 1, right);\r\n                                        const next_down_tree = new ProofBranchLine(1, next_instr_line, down_tree);\r\n                                        const up_tree = prop_helper(ln + 2, append(rev(passed), ofArray([left_1, right])), empty(), next_down_tree);\r\n                                        return new ProofTree(1, instr_line, new ProofTree(1, next_instr_line, up_tree));\r\n                                    }\r\n                                }\r\n                            }\r\n                            case 5: {\r\n                                return alpha_helper(ln, nodes_1, passed, tree, node_1, left_1, right);\r\n                            }\r\n                            case 4: {\r\n                                return beta_helper(ln, nodes_1, passed, tree, node_1, left_1, right);\r\n                            }\r\n                            case 7: {\r\n                                return beta_helper(ln, nodes_1, passed, tree, node_1, negate(left_1), right);\r\n                            }\r\n                            case 8: {\r\n                                return eta_helper(ln, nodes_1, passed, tree, node_1, left_1, right);\r\n                            }\r\n                            default: {\r\n                                ln_mut = ln;\r\n                                nodes_mut = nodes_1;\r\n                                passed_mut = passed;\r\n                                tree_mut = tree;\r\n                                continue prop_helper;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                const line_1 = matchValue;\r\n                if (prev != null) {\r\n                    const prev_1 = prev;\r\n                    return new ProofTree(0, new ProofLine(6, ln, line_1, prev_1));\r\n                }\r\n                else {\r\n                    throw (new Error(\"This should be unreachable.\"));\r\n                }\r\n            }\r\n        }\r\n        else if (!isEmpty(passed)) {\r\n            const node = head(passed);\r\n            if (node.tag === 1) {\r\n                const left = node.fields[1];\r\n                const true_branch_line = new ProofLine(7, ln, left);\r\n                const true_down_tree = new ProofBranchLine(1, true_branch_line, tree);\r\n                const true_up_tree = prop_helper(ln + 1, passed, empty(), true_down_tree);\r\n                const true_branch_tree = new ProofTree(1, true_branch_line, true_up_tree);\r\n                const false_branch_line = new ProofLine(7, ln, negate(left));\r\n                const false_down_tree = new ProofBranchLine(1, false_branch_line, tree);\r\n                const false_up_tree = prop_helper(ln + 1, passed, empty(), false_down_tree);\r\n                const false_branch_tree = new ProofTree(1, false_branch_line, false_up_tree);\r\n                return new ProofTree(2, true_branch_tree, false_branch_tree);\r\n            }\r\n            else {\r\n                throw (new Error(\"This should be unreachable\"));\r\n            }\r\n        }\r\n        else {\r\n            return new ProofTree(0, new ProofLine(5, ln));\r\n        }\r\n        break;\r\n    }\r\n}\r\n\r\nexport function alpha_helper(ln, nodes, passed, tree, node, left, right) {\r\n    let prev_instr_line;\r\n    const matchValue = in_branch(node, tree);\r\n    if (matchValue != null) {\r\n        const prev = matchValue;\r\n        prev_instr_line = prev;\r\n    }\r\n    else {\r\n        throw (new Error(\"This should be unreachable.\"));\r\n    }\r\n    const left_instr = new ProofLine(2, ln, prev_instr_line, left);\r\n    const right_instr = new ProofLine(2, ln + 1, prev_instr_line, right);\r\n    const down_tree = new ProofBranchLine(1, left_instr, new ProofBranchLine(1, right_instr, tree));\r\n    const up_tree = prop_helper(ln + 2, append(ofArrayWithTail([left, right], nodes), passed), empty(), down_tree);\r\n    return new ProofTree(1, left_instr, new ProofTree(1, right_instr, up_tree));\r\n}\r\n\r\nexport function beta_helper(ln, nodes, passed, tree, node, left, right) {\r\n    let prev_instr_line;\r\n    const matchValue = in_branch(node, tree);\r\n    if (matchValue != null) {\r\n        const prev = matchValue;\r\n        prev_instr_line = prev;\r\n    }\r\n    else {\r\n        throw (new Error(\"This should be unreachable.\"));\r\n    }\r\n    const matchValue_1 = in_branch(left, tree);\r\n    if (matchValue_1 == null) {\r\n        const matchValue_2 = in_branch(right, tree);\r\n        if (matchValue_2 == null) {\r\n            const matchValue_3 = neg_in_branch(left, tree);\r\n            if (matchValue_3 == null) {\r\n                const matchValue_4 = neg_in_branch(right, tree);\r\n                if (matchValue_4 == null) {\r\n                    return prop_helper(ln, nodes, cons(node, passed), tree);\r\n                }\r\n                else {\r\n                    const right_line = matchValue_4;\r\n                    const left_instr_line = new ProofLine(3, ln, prev_instr_line, right_line, left);\r\n                    const down_tree_1 = new ProofBranchLine(1, left_instr_line, tree);\r\n                    const up_tree_1 = prop_helper(ln + 1, cons(left, nodes), passed, down_tree_1);\r\n                    return new ProofTree(1, left_instr_line, up_tree_1);\r\n                }\r\n            }\r\n            else {\r\n                const left_line = matchValue_3;\r\n                const right_instr_line = new ProofLine(3, ln, prev_instr_line, left_line, right);\r\n                const down_tree = new ProofBranchLine(1, right_instr_line, tree);\r\n                const up_tree = prop_helper(ln + 1, cons(right, nodes), passed, down_tree);\r\n                return new ProofTree(1, right_instr_line, up_tree);\r\n            }\r\n        }\r\n        else {\r\n            return prop_helper(ln, nodes, passed, tree);\r\n        }\r\n    }\r\n    else {\r\n        return prop_helper(ln, nodes, passed, tree);\r\n    }\r\n}\r\n\r\nexport function eta_helper(ln, nodes, passed, tree, node, left, right) {\r\n    let prev_instr_line;\r\n    const matchValue = in_branch(node, tree);\r\n    if (matchValue != null) {\r\n        const prev = matchValue;\r\n        prev_instr_line = prev;\r\n    }\r\n    else {\r\n        throw (new Error(\"This should be unreachable.\"));\r\n    }\r\n    const matchValue_1 = in_branch(left, tree);\r\n    if (matchValue_1 == null) {\r\n        const matchValue_2 = neg_in_branch(left, tree);\r\n        if (matchValue_2 == null) {\r\n            const matchValue_3 = in_branch(right, tree);\r\n            if (matchValue_3 == null) {\r\n                const matchValue_4 = neg_in_branch(right, tree);\r\n                if (matchValue_4 == null) {\r\n                    return prop_helper(ln, nodes, cons(node, passed), tree);\r\n                }\r\n                else {\r\n                    const neg_right_line = matchValue_4;\r\n                    const neg_left = negate(left);\r\n                    const neg_right_instr_line = new ProofLine(4, ln, prev_instr_line, neg_right_line, neg_left);\r\n                    const down_tree_3 = new ProofBranchLine(1, neg_right_instr_line, tree);\r\n                    const up_tree_3 = prop_helper(ln + 1, append(cons(neg_left, nodes), passed), empty(), down_tree_3);\r\n                    return new ProofTree(1, neg_right_instr_line, up_tree_3);\r\n                }\r\n            }\r\n            else {\r\n                const right_line = matchValue_3;\r\n                const right_instr_line = new ProofLine(4, ln, prev_instr_line, right_line, left);\r\n                const down_tree_2 = new ProofBranchLine(1, right_instr_line, tree);\r\n                const up_tree_2 = prop_helper(ln + 1, append(cons(left, nodes), passed), empty(), down_tree_2);\r\n                return new ProofTree(1, right_instr_line, up_tree_2);\r\n            }\r\n        }\r\n        else {\r\n            const neg_left_line = matchValue_2;\r\n            const neg_right = negate(right);\r\n            const neg_left_instr_line = new ProofLine(4, ln, prev_instr_line, neg_left_line, neg_right);\r\n            const down_tree_1 = new ProofBranchLine(1, neg_left_instr_line, tree);\r\n            const up_tree_1 = prop_helper(ln + 1, append(cons(neg_right, nodes), passed), empty(), down_tree_1);\r\n            return new ProofTree(1, neg_left_instr_line, up_tree_1);\r\n        }\r\n    }\r\n    else {\r\n        const left_line = matchValue_1;\r\n        const left_instr_line = new ProofLine(4, ln, prev_instr_line, left_line, right);\r\n        const down_tree = new ProofBranchLine(1, left_instr_line, tree);\r\n        const up_tree = prop_helper(ln + 1, append(cons(right, nodes), passed), empty(), down_tree);\r\n        return new ProofTree(1, left_instr_line, up_tree);\r\n    }\r\n}\r\n\r\nexport function propopositional_solver(node) {\r\n    let right, op, left;\r\n    let pattern_matching_result;\r\n    if (node.tag === 1) {\r\n        if ((right = node.fields[2], (op = node.fields[0], (left = node.fields[1], equals(op, new Token(3)))))) {\r\n            pattern_matching_result = 0;\r\n        }\r\n        else {\r\n            pattern_matching_result = 1;\r\n        }\r\n    }\r\n    else {\r\n        pattern_matching_result = 1;\r\n    }\r\n    switch (pattern_matching_result) {\r\n        case 0: {\r\n            return prop_helper(0, singleton(node), empty(), new ProofBranchLine(0));\r\n        }\r\n        case 1: {\r\n            const up_tree = prop_helper(1, singleton(node), empty(), new ProofBranchLine(1, new ProofLine(0, 0, node), new ProofBranchLine(0)));\r\n            return new ProofTree(1, new ProofLine(0, 0, node), up_tree);\r\n        }\r\n    }\r\n}\r\n\r\n","import { tokenize } from \"./Lexer.fs.js\";\r\nimport { toList } from \"./.fable/fable-library.3.2.9/Seq.js\";\r\nimport { node_print, parse } from \"./Parser.fs.js\";\r\nimport { json_from_tree, print_tree, propopositional_solver } from \"./Propositional.fs.js\";\r\n\r\nexport function gen_interpretation(input) {\r\n    const tokens = tokenize(toList(input));\r\n    const ast = parse(tokens);\r\n    return node_print(ast);\r\n}\r\n\r\nexport function gen_text_tree(input) {\r\n    const tokens = tokenize(toList(input));\r\n    const ast = parse(tokens);\r\n    const proof_tree = propopositional_solver(ast);\r\n    return print_tree(proof_tree);\r\n}\r\n\r\nexport function gen_tree(input) {\r\n    const tokens = tokenize(toList(input));\r\n    const ast = parse(tokens);\r\n    const proof_tree = propopositional_solver(ast);\r\n    return json_from_tree(proof_tree);\r\n}\r\n\r\n"],"names":["equals","compare","toString","multiply","negate","numericCompare","dateToString","ofArray_1","ofSeq_1","head_1","tail_1"],"mappings":";;;IAAA;IAIO,SAAS,WAAW,CAAC,CAAC,EAAE;IAC/B,IAAI,OAAO,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,IAAI,WAAW,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;IACrD,CAAC;IAID,SAAS,YAAY,CAAC,CAAC,EAAE;IACzB,IAAI,OAAO,OAAO,CAAC,CAAC,SAAS,KAAK,UAAU,CAAC;IAC7C,CAAC;IACD,SAAS,WAAW,CAAC,CAAC,EAAE;IACxB,IAAI,OAAO,OAAO,CAAC,CAAC,MAAM,KAAK,UAAU,CAAC;IAC1C,CAAC;IACD,SAAS,UAAU,CAAC,CAAC,EAAE;IACvB,IAAI,OAAO,OAAO,CAAC,CAAC,WAAW,KAAK,UAAU,CAAC;IAC/C,CAAC;IAIM,SAAS,eAAe,CAAC,CAAC,EAAE,CAAC,EAAE;IACtC,IAAI,OAAO,MAAM,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC,WAAW,KAAK,MAAM,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC,WAAW,CAAC;IACzF,CAAC;IACM,MAAM,UAAU,CAAC;IACxB,IAAI,WAAW,CAAC,IAAI,EAAE;IACtB,QAAQ,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;IACzB,KAAK;IACL,IAAI,CAAC,sDAAsD,CAAC,GAAG;IAC/D,QAAQ,OAAO,IAAI,CAAC,OAAO,CAAC;IAC5B,KAAK;IACL,IAAI,CAAC,4CAA4C,CAAC,GAAG;IACrD,QAAQ,OAAO,IAAI,CAAC,OAAO,CAAC;IAC5B,KAAK;IACL,IAAI,CAAC,yCAAyC,CAAC,GAAG;IAClD,QAAQ,MAAM,GAAG,GAAG,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE,CAAC;IACrC,QAAQ,IAAI,CAAC,OAAO,GAAG,GAAG,CAAC,KAAK,CAAC;IACjC,QAAQ,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC;IACzB,KAAK;IACL,IAAI,CAAC,sCAAsC,CAAC,GAAG;IAC/C,QAAQ,MAAM,IAAI,KAAK,CAAC,8BAA8B,CAAC,CAAC;IACxD,KAAK;IACL,IAAI,OAAO,GAAG;IACd,QAAQ,OAAO;IACf,KAAK;IACL,CAAC;IACM,SAAS,aAAa,CAAC,CAAC,EAAE;IACjC,IAAI,OAAO,OAAO,CAAC,CAAC,aAAa,KAAK,UAAU;IAChD,UAAU,CAAC,CAAC,aAAa,EAAE;IAC3B,UAAU,IAAI,UAAU,CAAC,CAAC,CAAC,MAAM,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC;IAC/C,CAAC;IACM,SAAS,UAAU,CAAC,EAAE,EAAE;IAC/B,IAAI,OAAO;IACX,QAAQ,CAAC,MAAM,CAAC,QAAQ,CAAC,GAAG,EAAE,OAAO,IAAI,CAAC,EAAE;IAC5C,QAAQ,IAAI,GAAG;IACf,YAAY,MAAM,OAAO,GAAG,EAAE,CAAC,yCAAyC,CAAC,EAAE,CAAC;IAC5E,YAAY,MAAM,OAAO,GAAG,OAAO,GAAG,EAAE,CAAC,4CAA4C,CAAC,EAAE,GAAG,SAAS,CAAC;IACrG,YAAY,OAAO,EAAE,IAAI,EAAE,CAAC,OAAO,EAAE,KAAK,EAAE,OAAO,EAAE,CAAC;IACtD,SAAS;IACT,KAAK,CAAC;IACN,CAAC;IA2DM,SAAS,YAAY,CAAC,CAAC,EAAE,MAAM,EAAE;IACxC,IAAI,IAAI,GAAG,GAAG,CAAC,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC;IAC7B,IAAI,OAAO,GAAG,CAAC,MAAM,GAAG,MAAM,EAAE;IAChC,QAAQ,GAAG,GAAG,GAAG,GAAG,GAAG,CAAC;IACxB,KAAK;IACL,IAAI,OAAO,GAAG,CAAC;IACf,CAAC;IAWM,SAAS,UAAU,CAAC,IAAI,EAAE;IACjC,IAAI,MAAM,KAAK,GAAG,IAAI,CAAC;IACvB,IAAI,OAAO,OAAO,KAAK,CAAC,MAAM,KAAK,QAAQ;IAC3C,UAAU,KAAK,CAAC,MAAM;IACtB,WAAW,IAAI,CAAC,IAAI,KAAK,CAAC;IAC1B,cAAc,CAAC,GAAG,IAAI,CAAC,iBAAiB,EAAE,GAAG,CAAC,KAAK,CAAC,CAAC;IACrD,CAAC;IASM,MAAM,SAAS,CAAC;IACvB,IAAI,OAAO,EAAE,CAAC,CAAC,EAAE;IACjB,QAAQ,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE;IACrC,YAAY,SAAS,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,EAAE,EAAE,SAAS,CAAC,KAAK,CAAC,CAAC;IACtD,SAAS;IACT,QAAQ,OAAO,SAAS,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;IACtC,KAAK;IACL,CAAC;IACD,SAAS,CAAC,KAAK,GAAG,IAAI,OAAO,EAAE,CAAC;IAChC,SAAS,CAAC,KAAK,GAAG,CAAC,CAAC;IACb,SAAS,UAAU,CAAC,CAAC,EAAE;IAC9B,IAAI,IAAI,CAAC,GAAG,CAAC,CAAC;IACd,IAAI,IAAI,CAAC,GAAG,IAAI,CAAC;IACjB,IAAI,MAAM,GAAG,GAAG,CAAC,CAAC,MAAM,CAAC;IACzB,IAAI,OAAO,CAAC,GAAG,GAAG,EAAE;IACpB,QAAQ,CAAC,GAAG,CAAC,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC,UAAU,CAAC,CAAC,EAAE,CAAC,CAAC;IACzC,KAAK;IACL,IAAI,OAAO,CAAC,CAAC;IACb,CAAC;IACM,SAAS,UAAU,CAAC,CAAC,EAAE;IAC9B,IAAI,OAAO,CAAC,GAAG,UAAU,GAAG,CAAC,CAAC;IAC9B,CAAC;IACD;IACO,SAAS,gBAAgB,CAAC,MAAM,EAAE;IACzC,IAAI,IAAI,MAAM,CAAC,MAAM,KAAK,CAAC,EAAE;IAC7B,QAAQ,OAAO,CAAC,CAAC;IACjB,KAAK;IACL,IAAI,OAAO,MAAM,CAAC,MAAM,CAAC,CAAC,EAAE,EAAE,EAAE,KAAK;IACrC,QAAQ,OAAO,CAAC,CAAC,EAAE,IAAI,CAAC,IAAI,EAAE,IAAI,EAAE,CAAC;IACrC,KAAK,CAAC,CAAC;IACP,CAAC;IA2BM,SAAS,QAAQ,CAAC,CAAC,EAAE;IAC5B,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,CAAC;IACvB,CAAC;IACM,SAAS,SAAS,CAAC,CAAC,EAAE;IAC7B,IAAI,MAAM,GAAG,GAAG,CAAC,CAAC,MAAM,CAAC;IACzB,IAAI,MAAM,MAAM,GAAG,IAAI,KAAK,CAAC,GAAG,CAAC,CAAC;IAClC,IAAI,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,EAAE,CAAC,EAAE,EAAE;IAClC,QAAQ,MAAM,CAAC,CAAC,CAAC,GAAG,cAAc,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IACzC,KAAK;IACL,IAAI,OAAO,gBAAgB,CAAC,MAAM,CAAC,CAAC;IACpC,CAAC;IACM,SAAS,cAAc,CAAC,CAAC,EAAE;IAClC,IAAI,IAAI,CAAC,IAAI,IAAI,EAAE;IACnB,QAAQ,OAAO,CAAC,CAAC;IACjB,KAAK;IACL,IAAI,QAAQ,OAAO,CAAC;IACpB,QAAQ,KAAK,SAAS;IACtB,YAAY,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;IAC7B,QAAQ,KAAK,QAAQ;IACrB,YAAY,OAAO,UAAU,CAAC,CAAC,CAAC,CAAC;IACjC,QAAQ,KAAK,QAAQ;IACrB,YAAY,OAAO,UAAU,CAAC,CAAC,CAAC,CAAC;IACjC,QAAQ,SAAS;IACjB,YAAY,IAAI,UAAU,CAAC,CAAC,CAAC,EAAE;IAC/B,gBAAgB,OAAO,CAAC,CAAC,WAAW,EAAE,CAAC;IACvC,aAAa;IACb,iBAAiB,IAAI,WAAW,CAAC,CAAC,CAAC,EAAE;IACrC,gBAAgB,OAAO,SAAS,CAAC,CAAC,CAAC,CAAC;IACpC,aAAa;IACb,iBAAiB,IAAI,CAAC,YAAY,IAAI,EAAE;IACxC,gBAAgB,OAAO,QAAQ,CAAC,CAAC,CAAC,CAAC;IACnC,aAAa;IACb,iBAAiB,IAAI,MAAM,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC,WAAW,KAAK,MAAM,EAAE;IACtE;IACA,gBAAgB,MAAM,MAAM,GAAG,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,KAAK,cAAc,CAAC,CAAC,CAAC,CAAC,CAAC;IAC9E,gBAAgB,OAAO,gBAAgB,CAAC,MAAM,CAAC,CAAC;IAChD,aAAa;IACb,iBAAiB;IACjB;IACA,gBAAgB,OAAO,UAAU,CAAC,SAAS,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;IACnD;IACA,aAAa;IACb,SAAS;IACT,KAAK;IACL,CAAC;IASM,SAAS,eAAe,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE;IAC1C,IAAI,IAAI,CAAC,IAAI,IAAI,EAAE;IACnB,QAAQ,OAAO,CAAC,IAAI,IAAI,CAAC;IACzB,KAAK;IACL,IAAI,IAAI,CAAC,IAAI,IAAI,EAAE;IACnB,QAAQ,OAAO,KAAK,CAAC;IACrB,KAAK;IACL,IAAI,IAAI,CAAC,CAAC,MAAM,KAAK,CAAC,CAAC,MAAM,EAAE;IAC/B,QAAQ,OAAO,KAAK,CAAC;IACrB,KAAK;IACL,IAAI,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;IACvC,QAAQ,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE;IAC7B,YAAY,OAAO,KAAK,CAAC;IACzB,SAAS;IACT,KAAK;IACL,IAAI,OAAO,IAAI,CAAC;IAChB,CAAC;IACM,SAAS,WAAW,CAAC,CAAC,EAAE,CAAC,EAAE;IAClC,IAAI,OAAO,eAAe,CAAC,CAAC,EAAE,CAAC,EAAEA,QAAM,CAAC,CAAC;IACzC,CAAC;IACD,SAAS,YAAY,CAAC,CAAC,EAAE,CAAC,EAAE;IAC5B,IAAI,MAAM,KAAK,GAAG,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;IACjC,IAAI,MAAM,KAAK,GAAG,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;IACjC,IAAI,IAAI,KAAK,CAAC,MAAM,KAAK,KAAK,CAAC,MAAM,EAAE;IACvC,QAAQ,OAAO,KAAK,CAAC;IACrB,KAAK;IACL,IAAI,KAAK,CAAC,IAAI,EAAE,CAAC;IACjB,IAAI,KAAK,CAAC,IAAI,EAAE,CAAC;IACjB,IAAI,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;IAC3C,QAAQ,IAAI,KAAK,CAAC,CAAC,CAAC,KAAK,KAAK,CAAC,CAAC,CAAC,IAAI,CAACA,QAAM,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE;IACxE,YAAY,OAAO,KAAK,CAAC;IACzB,SAAS;IACT,KAAK;IACL,IAAI,OAAO,IAAI,CAAC;IAChB,CAAC;IACM,SAASA,QAAM,CAAC,CAAC,EAAE,CAAC,EAAE;IAC7B,IAAI,IAAI,CAAC,KAAK,CAAC,EAAE;IACjB,QAAQ,OAAO,IAAI,CAAC;IACpB,KAAK;IACL,SAAS,IAAI,CAAC,IAAI,IAAI,EAAE;IACxB,QAAQ,OAAO,CAAC,IAAI,IAAI,CAAC;IACzB,KAAK;IACL,SAAS,IAAI,CAAC,IAAI,IAAI,EAAE;IACxB,QAAQ,OAAO,KAAK,CAAC;IACrB,KAAK;IACL,SAAS,IAAI,OAAO,CAAC,KAAK,QAAQ,EAAE;IACpC,QAAQ,OAAO,KAAK,CAAC;IACrB,KAAK;IACL,SAAS,IAAI,WAAW,CAAC,CAAC,CAAC,EAAE;IAC7B,QAAQ,OAAO,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;IAC3B,KAAK;IACL,SAAS,IAAI,WAAW,CAAC,CAAC,CAAC,EAAE;IAC7B,QAAQ,OAAO,WAAW,CAAC,CAAC,CAAC,IAAI,WAAW,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;IACnD,KAAK;IACL,SAAS,IAAI,CAAC,YAAY,IAAI,EAAE;IAChC,QAAQ,OAAO,CAAC,CAAC,YAAY,IAAI,KAAK,YAAY,CAAC,CAAC,EAAE,CAAC,CAAC,KAAK,CAAC,CAAC;IAC/D,KAAK;IACL,SAAS;IACT,QAAQ,OAAO,MAAM,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC,WAAW,KAAK,MAAM,IAAI,YAAY,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;IACrF,KAAK;IACL,CAAC;IACM,SAAS,YAAY,CAAC,CAAC,EAAE,CAAC,EAAE;IACnC,IAAI,IAAI,KAAK,CAAC;IACd,IAAI,IAAI,KAAK,CAAC;IACd;IACA,IAAI,IAAI,QAAQ,IAAI,CAAC,IAAI,QAAQ,IAAI,CAAC,EAAE;IACxC,QAAQ,KAAK,GAAG,CAAC,CAAC,OAAO,EAAE,CAAC;IAC5B,QAAQ,KAAK,GAAG,CAAC,CAAC,OAAO,EAAE,CAAC;IAC5B,KAAK;IACL,SAAS;IACT,QAAQ,KAAK,GAAG,CAAC,CAAC,OAAO,EAAE,GAAG,UAAU,CAAC,CAAC,CAAC,CAAC;IAC5C,QAAQ,KAAK,GAAG,CAAC,CAAC,OAAO,EAAE,GAAG,UAAU,CAAC,CAAC,CAAC,CAAC;IAC5C,KAAK;IACL,IAAI,OAAO,KAAK,KAAK,KAAK,GAAG,CAAC,IAAI,KAAK,GAAG,KAAK,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;IAC1D,CAAC;IAIM,SAAS,iBAAiB,CAAC,CAAC,EAAE,CAAC,EAAE,IAAI,EAAE;IAC9C,IAAI,IAAI,CAAC,IAAI,IAAI,EAAE;IACnB,QAAQ,OAAO,CAAC,IAAI,IAAI,GAAG,CAAC,GAAG,CAAC,CAAC;IACjC,KAAK;IACL,IAAI,IAAI,CAAC,IAAI,IAAI,EAAE;IACnB,QAAQ,OAAO,CAAC,CAAC,CAAC;IAClB,KAAK;IACL,IAAI,IAAI,CAAC,CAAC,MAAM,KAAK,CAAC,CAAC,MAAM,EAAE;IAC/B,QAAQ,OAAO,CAAC,CAAC,MAAM,GAAG,CAAC,CAAC,MAAM,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC;IAC5C,KAAK;IACL,IAAI,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;IAC9C,QAAQ,CAAC,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IAC7B,QAAQ,IAAI,CAAC,KAAK,CAAC,EAAE;IACrB,YAAY,OAAO,CAAC,CAAC;IACrB,SAAS;IACT,KAAK;IACL,IAAI,OAAO,CAAC,CAAC;IACb,CAAC;IACM,SAAS,aAAa,CAAC,CAAC,EAAE,CAAC,EAAE;IACpC,IAAI,OAAO,iBAAiB,CAAC,CAAC,EAAE,CAAC,EAAEC,SAAO,CAAC,CAAC;IAC5C,CAAC;IACD,SAAS,cAAc,CAAC,CAAC,EAAE,CAAC,EAAE;IAC9B,IAAI,MAAM,KAAK,GAAG,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;IACjC,IAAI,MAAM,KAAK,GAAG,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;IACjC,IAAI,IAAI,KAAK,CAAC,MAAM,KAAK,KAAK,CAAC,MAAM,EAAE;IACvC,QAAQ,OAAO,KAAK,CAAC,MAAM,GAAG,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC;IACpD,KAAK;IACL,IAAI,KAAK,CAAC,IAAI,EAAE,CAAC;IACjB,IAAI,KAAK,CAAC,IAAI,EAAE,CAAC;IACjB,IAAI,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;IAClD,QAAQ,MAAM,GAAG,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;IAC7B,QAAQ,IAAI,GAAG,KAAK,KAAK,CAAC,CAAC,CAAC,EAAE;IAC9B,YAAY,OAAO,GAAG,GAAG,KAAK,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC;IAC3C,SAAS;IACT,aAAa;IACb,YAAY,CAAC,GAAGA,SAAO,CAAC,CAAC,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;IACxC,YAAY,IAAI,CAAC,KAAK,CAAC,EAAE;IACzB,gBAAgB,OAAO,CAAC,CAAC;IACzB,aAAa;IACb,SAAS;IACT,KAAK;IACL,IAAI,OAAO,CAAC,CAAC;IACb,CAAC;IACM,SAASA,SAAO,CAAC,CAAC,EAAE,CAAC,EAAE;IAC9B,IAAI,IAAI,CAAC,KAAK,CAAC,EAAE;IACjB,QAAQ,OAAO,CAAC,CAAC;IACjB,KAAK;IACL,SAAS,IAAI,CAAC,IAAI,IAAI,EAAE;IACxB,QAAQ,OAAO,CAAC,IAAI,IAAI,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;IAClC,KAAK;IACL,SAAS,IAAI,CAAC,IAAI,IAAI,EAAE;IACxB,QAAQ,OAAO,CAAC,CAAC;IACjB,KAAK;IACL,SAAS,IAAI,OAAO,CAAC,KAAK,QAAQ,EAAE;IACpC,QAAQ,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC;IAC9B,KAAK;IACL,SAAS,IAAI,YAAY,CAAC,CAAC,CAAC,EAAE;IAC9B,QAAQ,OAAO,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;IAC9B,KAAK;IACL,SAAS,IAAI,WAAW,CAAC,CAAC,CAAC,EAAE;IAC7B,QAAQ,OAAO,WAAW,CAAC,CAAC,CAAC,GAAG,aAAa,CAAC,CAAC,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;IACzD,KAAK;IACL,SAAS,IAAI,CAAC,YAAY,IAAI,EAAE;IAChC,QAAQ,OAAO,CAAC,YAAY,IAAI,GAAG,YAAY,CAAC,CAAC,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;IAC3D,KAAK;IACL,SAAS;IACT,QAAQ,OAAO,MAAM,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC,WAAW,KAAK,MAAM,GAAG,cAAc,CAAC,CAAC,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;IAC3F,KAAK;IACL;;ICvZO,SAAS,WAAW,CAAC,IAAI,EAAE;IAClC,IAAI,IAAI,KAAK,GAAG,CAAC,CAAC;IAClB,IAAI,IAAI,GAAG,GAAG,GAAG,CAAC;IAClB,IAAI,KAAK,MAAM,CAAC,IAAI,IAAI,EAAE;IAC1B,QAAQ,IAAI,KAAK,KAAK,CAAC,EAAE;IACzB,YAAY,GAAG,IAAIC,UAAQ,CAAC,CAAC,CAAC,CAAC;IAC/B,SAAS;IACT,aAAa,IAAI,KAAK,KAAK,GAAG,EAAE;IAChC,YAAY,GAAG,IAAI,OAAO,CAAC;IAC3B,YAAY,MAAM;IAClB,SAAS;IACT,aAAa;IACb,YAAY,GAAG,IAAI,IAAI,GAAGA,UAAQ,CAAC,CAAC,CAAC,CAAC;IACtC,SAAS;IACT,QAAQ,KAAK,EAAE,CAAC;IAChB,KAAK;IACL,IAAI,OAAO,GAAG,GAAG,GAAG,CAAC;IACrB,CAAC;IACM,SAASA,UAAQ,CAAC,CAAC,EAAE,SAAS,GAAG,CAAC,EAAE;IAC3C,IAAI,IAAI,CAAC,IAAI,IAAI,IAAI,OAAO,CAAC,KAAK,QAAQ,EAAE;IAC5C,QAAQ,IAAI,OAAO,CAAC,CAAC,QAAQ,KAAK,UAAU,EAAE;IAC9C,YAAY,OAAO,CAAC,CAAC,QAAQ,EAAE,CAAC;IAChC,SAAS;IACT,aAAa,IAAI,MAAM,CAAC,QAAQ,IAAI,CAAC,EAAE;IACvC,YAAY,OAAO,WAAW,CAAC,CAAC,CAAC,CAAC;IAClC,SAAS;IACT,aAAa;IACb,YAAY,MAAM,IAAI,GAAG,MAAM,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC,WAAW,CAAC;IAC9D,YAAY,OAAO,IAAI,KAAK,MAAM,IAAI,SAAS,GAAG,EAAE;IACpD;IACA,kBAAkB,IAAI,GAAG,MAAM,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,KAAK,CAAC,GAAG,KAAK,GAAGA,UAAQ,CAAC,CAAC,EAAE,SAAS,GAAG,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,GAAG,IAAI;IACtH,kBAAkB,IAAI,CAAC,IAAI,CAAC;IAC5B,SAAS;IACT,KAAK;IACL,IAAI,OAAO,MAAM,CAAC,CAAC,CAAC,CAAC;IACrB,CAAC;IACM,SAAS,aAAa,CAAC,IAAI,EAAE,MAAM,EAAE;IAC5C,IAAI,IAAI,MAAM,CAAC,MAAM,KAAK,CAAC,EAAE;IAC7B,QAAQ,OAAO,IAAI,CAAC;IACpB,KAAK;IACL,SAAS;IACT,QAAQ,IAAI,QAAQ,GAAG,EAAE,CAAC;IAC1B,QAAQ,IAAI,UAAU,GAAG,IAAI,CAAC;IAC9B,QAAQ,IAAI,MAAM,CAAC,MAAM,KAAK,CAAC,EAAE;IACjC,YAAY,QAAQ,GAAGA,UAAQ,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;IAC3C,YAAY,UAAU,GAAG,QAAQ,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;IACpD,SAAS;IACT,aAAa;IACb,YAAY,QAAQ,GAAG,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC,KAAKA,UAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IACjE,SAAS;IACT,QAAQ,OAAO,IAAI,IAAI,UAAU,GAAG,IAAI,GAAG,GAAG,CAAC,GAAG,QAAQ,IAAI,UAAU,GAAG,GAAG,GAAG,EAAE,CAAC,CAAC;IACrF,KAAK;IACL,CAAC;IACM,MAAM,KAAK,CAAC;IACnB,IAAI,IAAI,IAAI,GAAG;IACf,QAAQ,OAAO,IAAI,CAAC,KAAK,EAAE,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;IACtC,KAAK;IACL,IAAI,MAAM,GAAG;IACb,QAAQ,OAAO,IAAI,CAAC,MAAM,CAAC,MAAM,KAAK,CAAC,GAAG,IAAI,CAAC,IAAI,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;IACtF,KAAK;IACL,IAAI,QAAQ,GAAG;IACf,QAAQ,OAAO,aAAa,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC;IACrD,KAAK;IACL,IAAI,WAAW,GAAG;IAClB,QAAQ,MAAM,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC,KAAK,cAAc,CAAC,CAAC,CAAC,CAAC,CAAC;IACjE,QAAQ,MAAM,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,EAAE,UAAU,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC;IAClD,QAAQ,OAAO,gBAAgB,CAAC,MAAM,CAAC,CAAC;IACxC,KAAK;IACL,IAAI,MAAM,CAAC,KAAK,EAAE;IAClB,QAAQ,IAAI,IAAI,KAAK,KAAK,EAAE;IAC5B,YAAY,OAAO,IAAI,CAAC;IACxB,SAAS;IACT,aAAa,IAAI,CAAC,eAAe,CAAC,IAAI,EAAE,KAAK,CAAC,EAAE;IAChD,YAAY,OAAO,KAAK,CAAC;IACzB,SAAS;IACT,aAAa,IAAI,IAAI,CAAC,GAAG,KAAK,KAAK,CAAC,GAAG,EAAE;IACzC,YAAY,OAAO,WAAW,CAAC,IAAI,CAAC,MAAM,EAAE,KAAK,CAAC,MAAM,CAAC,CAAC;IAC1D,SAAS;IACT,aAAa;IACb,YAAY,OAAO,KAAK,CAAC;IACzB,SAAS;IACT,KAAK;IACL,IAAI,SAAS,CAAC,KAAK,EAAE;IACrB,QAAQ,IAAI,IAAI,KAAK,KAAK,EAAE;IAC5B,YAAY,OAAO,CAAC,CAAC;IACrB,SAAS;IACT,aAAa,IAAI,CAAC,eAAe,CAAC,IAAI,EAAE,KAAK,CAAC,EAAE;IAChD,YAAY,OAAO,CAAC,CAAC,CAAC;IACtB,SAAS;IACT,aAAa,IAAI,IAAI,CAAC,GAAG,KAAK,KAAK,CAAC,GAAG,EAAE;IACzC,YAAY,OAAO,aAAa,CAAC,IAAI,CAAC,MAAM,EAAE,KAAK,CAAC,MAAM,CAAC,CAAC;IAC5D,SAAS;IACT,aAAa;IACb,YAAY,OAAO,IAAI,CAAC,GAAG,GAAG,KAAK,CAAC,GAAG,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC;IACjD,SAAS;IACT,KAAK;IACL,CAAC;IACD,SAAS,YAAY,CAAC,IAAI,EAAE;IAC5B,IAAI,MAAM,CAAC,GAAG,EAAE,CAAC;IACjB,IAAI,MAAM,IAAI,GAAG,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IACnC,IAAI,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;IAC1C,QAAQ,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;IACnC,KAAK;IACL,IAAI,OAAO,CAAC,CAAC;IACb,CAAC;IACD,SAAS,cAAc,CAAC,IAAI,EAAE;IAC9B,IAAI,OAAO,IAAI,GAAG,MAAM,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,KAAK,CAAC,GAAG,KAAK,GAAGA,UAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,GAAG,IAAI,CAAC;IACpG,CAAC;IACD,SAAS,iBAAiB,CAAC,IAAI,EAAE;IACjC,IAAI,MAAM,MAAM,GAAG,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,KAAK,cAAc,CAAC,CAAC,CAAC,CAAC,CAAC;IACrE,IAAI,OAAO,gBAAgB,CAAC,MAAM,CAAC,CAAC;IACpC,CAAC;IACD,SAAS,YAAY,CAAC,IAAI,EAAE,KAAK,EAAE;IACnC,IAAI,IAAI,IAAI,KAAK,KAAK,EAAE;IACxB,QAAQ,OAAO,IAAI,CAAC;IACpB,KAAK;IACL,SAAS,IAAI,CAAC,eAAe,CAAC,IAAI,EAAE,KAAK,CAAC,EAAE;IAC5C,QAAQ,OAAO,KAAK,CAAC;IACrB,KAAK;IACL,SAAS;IACT,QAAQ,MAAM,SAAS,GAAG,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IAC5C,QAAQ,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,SAAS,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;IACnD,YAAY,IAAI,CAACF,QAAM,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,EAAE,KAAK,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE;IAClE,gBAAgB,OAAO,KAAK,CAAC;IAC7B,aAAa;IACb,SAAS;IACT,QAAQ,OAAO,IAAI,CAAC;IACpB,KAAK;IACL,CAAC;IACD,SAAS,eAAe,CAAC,IAAI,EAAE,KAAK,EAAE;IACtC,IAAI,IAAI,IAAI,KAAK,KAAK,EAAE;IACxB,QAAQ,OAAO,CAAC,CAAC;IACjB,KAAK;IACL,SAAS,IAAI,CAAC,eAAe,CAAC,IAAI,EAAE,KAAK,CAAC,EAAE;IAC5C,QAAQ,OAAO,CAAC,CAAC,CAAC;IAClB,KAAK;IACL,SAAS;IACT,QAAQ,MAAM,SAAS,GAAG,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IAC5C,QAAQ,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,SAAS,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;IACnD,YAAY,MAAM,MAAM,GAAGC,SAAO,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,EAAE,KAAK,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IAC5E,YAAY,IAAI,MAAM,KAAK,CAAC,EAAE;IAC9B,gBAAgB,OAAO,MAAM,CAAC;IAC9B,aAAa;IACb,SAAS;IACT,QAAQ,OAAO,CAAC,CAAC;IACjB,KAAK;IACL,CAAC;IACM,MAAM,MAAM,CAAC;IACpB,IAAI,MAAM,GAAG,EAAE,OAAO,YAAY,CAAC,IAAI,CAAC,CAAC,EAAE;IAC3C,IAAI,QAAQ,GAAG,EAAE,OAAO,cAAc,CAAC,IAAI,CAAC,CAAC,EAAE;IAC/C,IAAI,WAAW,GAAG,EAAE,OAAO,iBAAiB,CAAC,IAAI,CAAC,CAAC,EAAE;IACrD,IAAI,MAAM,CAAC,KAAK,EAAE,EAAE,OAAO,YAAY,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC,EAAE;IACvD,IAAI,SAAS,CAAC,KAAK,EAAE,EAAE,OAAO,eAAe,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC,EAAE;IAC7D;;IC1JA;IACO,IAAI,YAAY,CAAC;IACxB,CAAC,UAAU,YAAY,EAAE;IACzB;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAI,YAAY,CAAC,YAAY,CAAC,mBAAmB,CAAC,GAAG,GAAG,CAAC,GAAG,mBAAmB,CAAC;IAChF;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,CAAC,EAAE,YAAY,KAAK,YAAY,GAAG,EAAE,CAAC,CAAC;;ICxBhC,MAAM,MAAM,GAAG,MAAM,CAAC,SAAS,CAAC,CAAC;IACjC,SAAS,SAAS,CAAC,CAAC,EAAE;IAC7B,IAAI,OAAO,OAAO,CAAC,KAAK,QAAQ,KAAK,CAAC,KAAK,IAAI,IAAI,CAAC,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC;IACtF,CAAC;IACM,SAASA,SAAO,CAAC,CAAC,EAAE,CAAC,EAAE;IAC9B,IAAI,IAAI,OAAO,CAAC,KAAK,QAAQ,EAAE;IAC/B,QAAQ,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;IAC5C,KAAK;IACL,SAAS;IACT,QAAQ,OAAO,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;IAC9B,KAAK;IACL,CAAC;IACM,SAASE,UAAQ,CAAC,CAAC,EAAE,CAAC,EAAE;IAC/B,IAAI,IAAI,OAAO,CAAC,KAAK,QAAQ,EAAE;IAC/B,QAAQ,OAAO,CAAC,GAAG,CAAC,CAAC;IACrB,KAAK;IACL,SAAS;IACT,QAAQ,OAAO,CAAC,CAAC,MAAM,CAAC,EAAE,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;IACvC,KAAK;IACL,CAAC;IACM,SAAS,OAAO,CAAC,CAAC,EAAE,EAAE,EAAE;IAC/B,IAAI,IAAI,OAAO,CAAC,KAAK,QAAQ,EAAE;IAC/B,QAAQ,OAAO,CAAC,CAAC,OAAO,CAAC,EAAE,CAAC,CAAC;IAC7B,KAAK;IACL,SAAS;IACT,QAAQ,OAAO,CAAC,CAAC,MAAM,CAAC,EAAE,CAAC,OAAO,CAAC,EAAE,CAAC,CAAC;IACvC,KAAK;IACL,CAAC;IACM,SAAS,WAAW,CAAC,CAAC,EAAE,EAAE,EAAE;IACnC,IAAI,IAAI,OAAO,CAAC,KAAK,QAAQ,EAAE;IAC/B,QAAQ,OAAO,CAAC,CAAC,WAAW,CAAC,EAAE,CAAC,CAAC;IACjC,KAAK;IACL,SAAS;IACT,QAAQ,OAAO,CAAC,CAAC,MAAM,CAAC,EAAE,CAAC,WAAW,CAAC,EAAE,CAAC,CAAC;IAC3C,KAAK;IACL,CAAC;IACM,SAAS,aAAa,CAAC,CAAC,EAAE,EAAE,EAAE;IACrC,IAAI,IAAI,OAAO,CAAC,KAAK,QAAQ,EAAE;IAC/B,QAAQ,OAAO,CAAC,CAAC,aAAa,CAAC,EAAE,CAAC,CAAC;IACnC,KAAK;IACL,SAAS;IACT,QAAQ,OAAO,CAAC,CAAC,MAAM,CAAC,EAAE,CAAC,aAAa,CAAC,EAAE,CAAC,CAAC;IAC7C,KAAK;IACL,CAAC;IACM,SAAS,KAAK,CAAC,CAAC,EAAE;IACzB,IAAI,IAAI,OAAO,CAAC,KAAK,QAAQ,EAAE;IAC/B,QAAQ,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC,KAAK,CAAC,EAAE,QAAQ,CAAC,EAAE,CAAC,CAAC;IAC9C,KAAK;IACL,SAAS;IACT,QAAQ,OAAO,CAAC,CAAC,MAAM,CAAC,EAAE,CAAC,KAAK,EAAE,CAAC;IACnC,KAAK;IACL;;ICnDA;IAIA;IACA;IACA;IACA,IAAI,IAAI,GAAG,IAAI,CAAC;IAChB,IAAI;IACJ,IAAI,IAAI,GAAG,IAAI,WAAW,CAAC,QAAQ,CAAC,IAAI,WAAW,CAAC,MAAM,CAAC,IAAI,UAAU,CAAC;IAC1E,QAAQ,CAAC,EAAE,EAAE,EAAE,GAAG,EAAE,GAAG,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE,EAAE,GAAG,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE,EAAE,GAAG,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE,EAAE,GAAG,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE,EAAE,GAAG,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,GAAG,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,GAAG,EAAE,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"}